[{"content":"","date":"14 December 2022","permalink":"/categories/blog/","section":"Categories","summary":"","title":"blog"},{"content":"","date":"14 December 2022","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"14 December 2022","permalink":"/tags/coinbase/","section":"Tags","summary":"","title":"coinbase"},{"content":"","date":"14 December 2022","permalink":"/tags/cryptocurrency/","section":"Tags","summary":"","title":"cryptocurrency"},{"content":"","date":"14 December 2022","permalink":"/","section":"Owl's Paw","summary":"","title":"Owl's Paw"},{"content":"","date":"14 December 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"14 December 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"14 December 2022","permalink":"/tags/visa/","section":"Tags","summary":"","title":"visa"},{"content":"Разбераемся, что такое клиптовалюты и что делать в 2022-2023, если нам требуется оплатить что-то в интернете, но наши карточки не работают.\nРазберем способы, как через криптовалюты, так и через посредников.\nДисклеймер! Автор не несет ответственность за ваши средства, которые вы переводите куда-либо. Я не получаю никаких бонусов от coinbase, paywithmoon или обменников. Все, что я опишу ниже сработало для меня, но вы делаете это на свой страх и риск. Вводная # Кто мы? Потребитель из интернета! Чего мы хотим? Отдать деньги тем, кто их не берет! Звучит как шутка, но такова реальность. Наша цель сегодня \u0026ndash; научиться оплачивать сервисы, которые не могут или не хотят принимать платежи с нашим не работающих карт.\nСегодня мы научимся:\nПлатить за сервер DigitalOcean, на котором будет наш VPN; Платить за подписку на Netflix, Distrokid и тд; Покупать игры в американском PSn за крипту и в турецком за рубли и USDT; Покупать игры в Steam за рубли. Для реализации наших целей будем использовать целый арсенал сервисов, стейблкоинов, криптовалют и просто посредников.\nСервисы для работы через криптовалюту # Moon \u0026ndash; сервис, который выпускает предоплаченные карты visa на срок 3 месяца без возможности дополнительного пополнения. Открывать (делать первое пополнение) мы будем через Coinbase.\nCoinbase \u0026ndash; биржа, а также vault (wallet, keeper) для ваших монет. Хранить свои монеты там категорически не рекомендую, но как сервис-прокси coinbase самый подходящий под наши задачи. Покупать там мы ничего не сможем, так что вооружимся сервисом-агрегатором-обменником BestChange.\nBestChange \u0026ndash; сервис, агрегирующий обменники. Именно сюда мы будем нести свои рубли, который будем на выбранном обменнике менять на нужную монету.\nBitrefill \u0026ndash; сервис, на котором можно купить предоплаченные карты для разных сервисов 1 к 1 за Tether, например, для US-аккаунта PlayStation Store Gift Card на $50 за 50 USDT.\nBitlaunch \u0026ndash; сервис для покупки серверов за криптовалюту. Не сказать, что это анонимно, так как просит ввести email, но можно использовать всякие temp-mail сервисы и Monero, например.\nКриптовалюты, которые нам понадобятся # Tether, USDT (TRC-20, Tron) — это фиатная криптовалюта, так называемый stablecoin. Использовать мы будем её TRC-20 версию, т.е. все транзакции будут идти через сеть Tron. В Tron комиссия ниже, чем в Ethereum сети, да и Tron купить проще, как мне показалось.\nBitcoin \u0026ndash; в представлении не нуждается, я думаю. Первая и самая ликвидная крипто-монетка. При этом с кучей своих недостатков и достаточно медленными транзакциями.\nMonero \u0026ndash; это анонимная криптовалюта. Все транзакции в этой сети анонимны и достаточно быстрые. Благодаря этой монетке можно анонимно покупать серверы через bitlaunch, например, менять Monero на USDT и прч.\nИнструменты для хранения и обмена # Пошли мы покупать монетки, а куда их класть то? Для хранения будем использовать Exodus.\nExodus, дом для наших монет # Exodus — мультивалютный крипто-кошелек. Он мне понравится тем, что имеет клиент почти под всё:\nСписок клиентов\niOS клиент Android клиет Linux клиент (но я ставил через flathub) Mac клиент (можно через Brew) Windows клиент Имеет большой список поддерживаемых крипто-валют, и вообще\u0026hellip; красивенький.\nExodus это не холодный кошелек. Он является компромисом между вашей безопасностью и удобством, но это все ещё лучше использования для хранения крипто-бирж, хоть и не так безопасно, как холодные или hardware-кошельки, типа Ledger, которые в России вы не сможите купить.\nНачнем с установки клиента и первых необходимых манипуляций.\nУстановим клиент на нужное устройство. Я ставил на свой iOS смартфон, затем уже на Fedora Linux. Как установить на смартфон — объяснять не нужно: App Store ⇒ Exodus.\nПри первом запуске приложение немножко призадумается (генерирует вам первые кошелечки), потом вы увидите перед собой главный экран. Нам нужно добавить 2 валюты для наших делишек: Tron (тикер: TRX) и Tether (тикер: USDT, со значком TRX). Для этого листаем вниз наш экран, затем нажимаем кнопочку “Add Mode”. В поиске пишем нужный тикер и рычажком включаем.\nВалюты добавлены. Tether нам пока недоступен, потому что мы не провели ни одной транзакции по Tron-сети. Как только мы купим немного TRX, Tether сразу разблокируется.\nНам надо озаботится нашей безопасностью. Чтобы мы могли, например, поставить клиент еще и на PC или Mac и восстановить наши кошельки. Ну или в целом, чтобы мы могли восстановить наши кошельки. Для этого нажимаем на 4 квадратика в нижнем баре → Security → Backup → View Secret Phrase, зажимаем Press and Hold to Reveal и переписываем куда-нибудь на листочек 12 фраз именно в том порядке в котором идут. Очень важно сделать это без ошибок, так как иначе вы потеряете доступ ко всем своим кошелькам при утере доступа к этому приложению.\nПри установке клиента на другие устройства просто следуем в настройки и давим Restore from Backup, вводим последовательность.\nПриложение поставили, подключили 2 нужных валюты, выписали и надежно сохранили кодовую фразу — you are breathtaking! Можно покупать свою первую криптомонетку! Но для начала сделаем еще один обязательный шаг \u0026ndash; заведем Coinbase аккаунт, что бы подружить нашу крипту с Visa, а не просто перекладывать рубли в биты.\nCoinbase, крипто-биржа # Так как нам в первую очередь нужно делать Visa-карты, а не просто развлекаться с криптой при огромных комиссиях на конвертация, то нам нужна будет учетка на Coinbase. Собственно сделаем её.\nИдем на сайт с выключенным VPN, что бы вы регистрировались как RU-регион. Это нужно для того, чтобы не попасть под анальную модерацию документов как в германии, например. Вы попросту не сможете валидировать свою учетную запись. Первый раз я именно на этом и накололся, так что обратите внимание.\nРегистрация простая, так что описывать её нет смысла. После регистрации просто валидируйте личность в кабинете, там потребуется указать адрес и цель, с которой вы пришли на coinbase. При регистрации через мобильное приложение вас сразу об этом спросят.\nСобственно\u0026hellip; все! Теперь мы можем брать свой номер Bitcoin кошелька (в моб. приложении Pay ⇒ Receive ⇒ BTC address ⇒ copy).\nДелаем Visa-карту с USD # BestChange или как выменять плащ на пинту эля в “Гарцующем Пони” # Начинаем двигаться в сторону валидной Visa-карты.\nСразу оговоримся почему мы не покупаем крипту на биржах:\nCoinBase или Binance требует паспортных данных, а мы не хотим их передавать. Процесс ввода-вывода средств для России сейчас, по понятным причинам, слегка не возможен. Наш вариант BestChange. Это площадка с очень строгой модерацией, так что все обменники там как минимум подвергаются тщательным проверкам. Никакой регистрации не требуется.\nВ левом столбике выбираем, чего мы хотим заплатить (я, например, в Online Banking, выбрал там Tinkoff), справа выбираем, что хотим получить.\nДля начала прикупим немножечко Bitcoin. Замечу, чем меньше сумма, которую вы покупаете, тем дороже может стоить обмен.\nВыбираем, например, Tinkoff → Bitcoin и наблюдаем примерно следующую картину:\nВыбираем понравившийся нам обменник, обращая внимание на значки возле названия. Нам нужно чтобы мы погли купить монетки без валидации карточки и прч. фигни, так что ищем обменник, где нет плашки \u0026ldquo;This exchanger can require verification of client\u0026rsquo;s bank card.\u0026rdquo; Обмен будет дороже, зато без лишнего головняка.\nЕсли хочется просто быстро менять денюжков на монетки и вы не стесняетесь присылать фото своей карточки сервису, то я бы даже мог посоветовать Kassa.\nКогда вы выбрали обменник, сам обмен будет проходить по сценарию \u0026ldquo;ты мне \u0026ndash; я тебе\u0026rdquo;. Вы вводите сколько хотите купить, вам расскажут, сколько это будет стоить, после чего вы указываете свой BTC кошелек, который взяли с Coinbase и проводите оплату.\nВ случае с обычными обменниками вам просто скажут номер карты, куда отправить нужно точную сумму и нажать кнопку на сайте, что вы отправили, после чего через 10-15 минут вам поступят средства на ваш крипто-кошелек.\nВ случае с кассой, вроде как, все автоматизировано и платеж вы проводите прям на сервисе, а не в ручном режиме.\nКогда вы получили монеты на свой кошелек, можно приступать к созданию Visa-карты.\nMoon, превращаем вино обратно в воду # Идем на сервис Moon, регистрируемся там и привязываем свой coinbase аккаунт (Settings ⇒ Connect to Coinbase). Это нужно сделать для того, чтобы сервис мог видеть наш баланс и запрашивать Bitcoin из нашего кошелька.\nТеперь самое интересное \u0026ndash; создаем новую карточку.\nЖмем Create a new card, выбираем Payment Method \u0026ndash; Coinbase (BTC), вводим в Card Amount сколько мы хотим зачислить и нажимаем Continue. Я обычно ничего на coinbase не оставляю, так что у меня висит предупреждение.\nПосле чего сервис вам покажет вашу новую карту, где будет номер, дата и cvs-код.\nТеперь вы можете добавить эту карту в Apple Pay, Google Pay, использовать для оплаты любых сервисов и тд.\nВезде, где потребуется указывать конкретный адрес плательщика, нужно будет взять любой рандомный адрес с тех же гугл-карт. Для нашей карточки нудно брать US адрес.\nОплачиваем на DigitalOcean # Почему разбираем пример с DigitalOcean? Потому что после июня 2022 года нельзя просто добавить карту как платежное средство. DigitalOcean перестал принимать предоплаченные карты и это хороший пример для разбора подобных ситуаций.\nЕсли мы не можем указать предоплаченную карту в качестве платежного средства, то у нас есть 2 варианта:\nИспользовать PayPal в качестве прокси-платежки, если у вас есть аккаунт не в России; Добавить карту в Apple Pay, Google Pay и тд. Я буду пользоваться вторым вариантом, потому что у меня с PayPall не прокатило: не дали сменить регион.\nПроходим процедуру добавления карточки в Apple Pay, для этого заблаговременно находим нам фейковый платежный адрес, например, на Google Map, просто ткнув в понравившейся дом, строение или гараж какой-нибудь, и ищем ZIP-code для него, например тут. Я выбрал штат Nashville, конкретный адрес публиковать не буду по понятным причинам.\nКогда карточка будет успешно добавлена в Apple/Google Pay, заходим в личный кабинет через Safari, если у вас iOS и через chrome, если Android. Это важно, так как вам просто не отобразится в ином случае оплата через \u0026lt;\u0026hellip;\u0026gt; Pay:\nВот пример из браузера на PC или Firefox на iOS\nВот пример из Safari, появилась оплата Apple Pay:\nНажимаем оплату ApplePay, производим оплату и все, успех:\nПользуясь этой информацией можно пробовать оплачивать всякие подписочные сервисы, которые не принимают предоплаченные карту.\nВ любом другом случае просто указываете свою карточку в качестве основного платежного средства и все, все будет работать. Я проверял это на сервисе Distrokid, годовая подписка без проблем списалась с этой карточки.\nС прямыми оплатами понятно, а теперь посмотрим, что можно сделать через всякие прокси-сервисы.\nBitrefill, покупаем gift-карты для PSN, Netflix и тд. # Теперь упростим задачу. Мы не хотим регистрировать Coinbase аккаунт. Мы не хотим возиться с Visa-картами. Мы просто хотим принести крипту, которую купили и забрать код / gift / или что-то еще.\nИ снова в обменники # Первым делом закупимся криптой, на этот раз будем покупать USDT и Tron. Вспомним про наш Exodus, а точнее про первые шаги, описанные здесь. Нам требовалось добавить новые валюты, TRX и USDT. Можно сразу ответить на немой вопрос, зачем два если будем покупать за один? Все просто, для транзакций USDT использует сеть Tron (TRC-20), за каждую транзакцию мы обязаны оставлять \u0026ldquo;чаевые\u0026rdquo;. И вот чтобы оплачивать такую комиссию \u0026ndash; нужны TRX.\nДля покупки повторяем шаги, описанные здесь, только выбираем не Bitcoin, а Tron (TRX).\nЯ свои TRX покупал на coinstar. Ценник высоковат, зато можно купить минимальной порцией чуть ли не от 800-900 рублей, но мы же здесь попробовать, верно? Так что за любопытство заплатим немножко больше.\nЗаполняем необходимые поля. Номер своего Tron (TRX) кошелька можно скопировать из Exodus. На главном экране нажимаем на TRX → Стрелочка, направленная вниз → Your TRX Address (тапни, что бы копировать).\nДалее вам выдадут номер карты на которую нужно совершить перевод и после нажмете соответствующую кнопочку на сайте. 5-10 минут и TRX будут зачислены.\nПосле этого у вас разблокируется и USDT, потому что у вас будет проведена транзакция по Tron сети и будут TRX для оплаты tee за переводы (1 перевод 3-8 TRX).\nЯ также еще покупал Monero. Это анонимная криптовалюта и анонимный блокчейн. А так же его легко конвертировать в USDT, например вот тут. Но это вовсе не обязательно. USDT (TRC-20) вы можете купить и за рубли используя всё тот же BestChange.\nВажно! Всегда проверяйте, что вы покупаете или переводите средства через TRC-20 сеть, потому что мы используем Tron, иначе монетки не попадут к вам на счет и никто не вернет вам деньги. Если вы хотите использовать другую сеть, то для начала добавьте в Exodus нужные ассеты, пример на скриншоте ниже. Покупаем gift # Теперь у нас есть USDT и мы хотим купить себе gift-карту, например, для американского PSN, пусть будет на $50.\nИдем на Bitrefill, выбираем сверху USA, проваливаемся в раздел Gift Cards и категорию Games.\nДалее находим интересующий нас gift. В нашем случае PlayStation Store, выбираем, сколько нам нужно и средство оплаты указываем USDT.\nДальше просто следуем инструкции. На экране оплаты должен появиться QR-код. Сканируете его через Exodus, оплачиваете и ждете подарок на почту.\nПокупаем игры на турецкий PSN-аккаунт # До недавнего времени можно было сделать себе карту в каком-нибудь Ozan, переводить деньги на счёт через Swith и тд и тп. Теперь такой возможности нет, но есть лазейки.\nЭто часть заметки для тех, кто не хочет переплачивать посреднику, если вы не из таких, смело листайте ниже до раздела покупки через третьих лиц.\nВиртуальная карта OlduBil + USDT # Устанавливаем на свой смартфон приложение OlduBil (iOS, Android). При регистрации указывайте регион \u0026ldquo;Казахстан\u0026rdquo;, у них код тоже +7 и смс будут приходить без проблем.\nПолностью описывать процесс я не буду, так как пользователь DTF \u0026ndash; Йети сделал это за меня в этой большой статье.\nНадо отметить, что в его способе используется Binance. Как сейчас обстоит дело не могу сказать, но зато вы не сильно переплатите при покупки таким способом.\nЭтот способ я лично не проверял, но включать в эту заметку ссылку на этот способ стоило. Кто пользовался этим методом, вроде как, все отзываются положительно. Сам я не буду проверять, т.к. не хочу регистрироваться на Binance.\nПокупка через посредника # Тут будет все гораздо проще, ну и заметно дороже.\nЯ покупал непосредственно через этих ребят.\nПроцесс очень простой, вы закидываете в свою карзину все, что хотите купить, умножаете получившийся ценник на 5, что бы понимать, сколько это будет вам стоить, пишете ему, передаёте логин и пароль от турецкого аккаунта и ждете дальнейших указаний.\nПродавец услуги вам скажет, что сейчас можно нажать \u0026ldquo;купить\u0026rdquo;. Всё. Дальше вы просто оплачиваете ему услугу. Т.е. сначала он покупает вам все, что нужно, после вы оплачиваете.\nВы ничем не рискуете. Но не надо пытаться обмануть как-то продавца, это плохо кончится, т.е. там есть большой чат единомышленников, который просто закидает ваш аккаунт репортами, с пометкой, что вы оплачиваете товар краденной картой.\nSteam \u0026ndash; переезд в Казахстан # Из ру-региона ушли многие издатели, страница в steam очень победнела, а купить игры, те, которые еще не успели уйти, стало проблематично.\nСервисы пополнения кошелька steam есть и их много, но что покупать-то?\nРешим проблему проще \u0026ndash; мы едем в Казахстан.\nПредварительные приготовления # Я советую сделать вам перечень следующих действий перед тем, как мы отправимся к продавцу услуги:\nЗайти сюда и проверить, что бы было пусто. Если что-то есть \u0026ndash; удаляем; Сменить пароль за пару дней до процедуры; За пару дней до смены региона не проводить никаких сделок на площадке и не покупать игры; Подключить, если не была подключена, двухфакторная авторизация. Все это позволит свести к минимуму откат региона.\nПереезжаем # Идем за услугой сюда. Никаких VPN включать не нужно. Не лишним будет почитать FAQ, который для вас составил автор; Покупаем услугу и просто ждем, когда с вами свяжется продавец (как правило минут 10-15); Общаетесь с продавцом, предоставляете ему данные от аккаунта, код двухфакторной авторизации и тд; Он покупает на ваш аккаунт с новой виртуальной карты какую-то мелочь, и у вас меняется регион. Данный по карте в виде скриншота продавец вам скидывает в том же чате. Это на случай, если steam всё же решит октатить вам регион (на моей памяти ни у кого, при соблюдении правил, не откатывали).\nВажно!\nНе возвращайте купленную продавцом игру, это приведет к откату региона! Воздержитесь от пополнения кошелька день-другой. После того, как вам сменили регион самое время задуматься, как заводить деньги на свой обновленный аккаунт. На помощь нам придёт Qiwi или Web Money (с его просто анальной модерацией).\nQiwi # Устанавливаем приложение на свой смартфон (iOS, Android); После регистрации подтвержаем статус аккаунта через гос-услуги; Заводим новый Тенге-кошелек: Чтобы пополнить Тенге-кошелек, сначала пополняем рублевый счет, потом уже Тенге-счет.\nДалее просто пополняете свой Steam аккаунт. Ищите в поиске qiwi Steam (Казахстан) и вводите свой steam-логин.\nПару слов о WebMoney # С WM все будет несколько сложнее. Вам, без шуток, придется читать стихотворение на камеру с паспортом в руках. Я этого делать не хочу, но вы должны знать и о таком методе оплаты.\nКомиссия через WM ниже, чем через Qiwi, но не на столько, что бы возиться с подтверждением своего аккаунта.\n","date":"14 December 2022","permalink":"/posts/crypto-visa/","section":"Posts","summary":"Разбераемся, что такое клиптовалюты и что делать в 2022-2023, если нам требуется оплатить что-то в интернете, но наши карточки не работают.","title":"Валидная Visa, оплата покупок в интернете или \"Крипта, туда и обратно\""},{"content":"","date":"11 December 2022","permalink":"/tags/armstrong/","section":"Tags","summary":"","title":"armstrong"},{"content":"Познакомимся с ARMStrong, рассмотрим принципы построения и задачи, которые перед нами стоят.\nARMStrong (Automated Radiation Monitoring System) — автоматизированная система радиационного контроля, (далее СРК) включающая в себя комплекс средств, призванных осуществлять радиационный контроль, в целях снижения травматизма, предупреждения предаварийных ситуация и недопущения развития аварийных сценариев.\nСистема представляет собой open-source набор средств, призванный решать строго определенный набор задач. Авторы не несут ответственность и предоставляют систему \u0026ldquo;как есть\u0026rdquo;.\nВесь код по мере доработки будет публиковаться в репозитории Digital Armstrong. Все контакты для связи указаны в шапке репозитория.\nБазовая архитектура # ARMStrong реализует базовую трехуровневую архитектуру представленной на рисунке 1, и является вторым и третьим уровни соответственно.\nНазначение # ARMStrong на сегодняшний день обеспечен следующим функционалом:\nСбор, обработка и хранение информации с блоков детектирования (далее БД); Осуществление управления БД; Агрегирование данных с целью в виде числовых значений и графиков; Свето-звуковое оповещение при превышении предаварийных и аварийных пороговых значений; В будущем присутствует возможность добавления функционала для:\nРасширения парка поддерживаемых устройств с аналоговым выходом или поддерживающих протокол RS-485, например, управление электромагнитными клапанами или новым БД; Построения тепловых карт по собранным данным; Архитектура 2-го и 3-го уровня # Второй уровень представляет собой измерительные каналы и каналы свето-звуковой сигнализации. Каналы объединяются параллельно и подключаются к серверу сбора и обработки данных (далее ССОД) по RS-485 линии связи.\nВ свою очередь ССОД после получения и обработки данных с измерительных каналов сохраняет значения в базу данных, расположенной на сервере (далее СБД).\nКоммутатор устанавливается для объединения всех серверов в стойке в одну локальную сеть, чтобы ССОД могли иметь доступ до СБД.\nМаршрутизатор устанавливается в стойку для организации локальной сети внутри каждой серверной стойки, что повышает отказоустойчивость в случае обесточения и отказа внешних маршрутизаторов. Организация доступа к данным может осуществляться как прямыми запросами в базу данных, так и через API для зарегистрированных и аутентифицированных WEB-клиентов.\nHardware уровень # Измерительный канал, который получил название АСРК (Автоматизированное Средство Радиационного Контроля) выполнен на печатной плате на базе микроконтроллера ATMega-8. Интерфейсы подключения:\nАналоговый вход: разъем типа РМ; Комбинированный выход: коннектор 5-pin (2-pin A-B Data + 3-pin DC 12V); Логические выходы: штырьковые разъемы. Размеры одного готового к подключению канала всего 70 * 35 * 35 миллиметров, а без разъема типа РМ и вовсе составляет 42 * 21 миллиметра.\nИзмерительный канал подключается к персональному компьютеру или серверу при помощи преобразователя интерфейсов RS-485 \u0026ndash;\u0026gt; USB. В нашем случае используется преобразователь интерфейсов ОВЕН АС4-М\nПО контроллера # Програмное обеспечение контроллера (далее ПОК) написано на языке программирования C и скомпилированно под ATMega 8.\nПОК реализует самописный протокол обмена данными, который основан на стандартизированном промышленном протоколе Modbus.\nПОК позволяет осуществлять:\nНазначение адреса канала; Назначение режима обработки сигнала от БД (Частотный / Времянной / Счет отключен) Управление бленкером, генератором и другими средствами самопроверки БД; Осуществление перемотки кадра лентопротяжного механизма БД; Управление свето-звуковой сигнализацией. Опрос значений измерений БД; Управление свето-звуковой сигнализацией. Предоставляемые возможности # Помимо описанных возможностей в разделе ПО контроллера, канал связи может быть исполнен в разных конфигурациях и с разным количеством логических портов.\nКанал связи может быть дооснащен дисплеем и аккумулятором, и использован в качестве автономного, носимого, прямопоказывающего БОИ (блока обработки информации), для подключаемого к нему БД.\nТакже канал связи может быть использован в качестве дооснащения существующих БД или при изготовлении новых БД для организации прямого подключения, т.к. размеры платы очень малы, а потребление всего 0.010-0.015 Ампера.\nСфера применения платы канала связи АСРК не ограничивается только стационарными решениями для обеспечения радиационной безопасности, за счет малого потребления тока и малых габаритов это устройство может помогать решать достаточно широкий спектр задач.\nСерверный уровень # Уровень хранения информации # База данных # В качестве сервера базы данных в нашем случае используется сервер \u0026hellip; оснащенный 4 жесткими дисками, емкостью по 4 террабайта каждый и обьединенными в RAID10 массив, что повышает отказоустойчивость и осуществляет первичное резервирование данны.\nВажно!\nКаждый такой сервер, обеспечивающий работу базы данных, должен быть оснащен дополнительным комплектом из минимум 4-х аналогичных жестких дисков для обеспечения подменного фонда.\nНа сервер установлена бесплатная, с открытым исходным кодом операционная система на базе ядра Linux — Ubuntu 20.04 LTS.\nВ качестве СУБД используется бесплатная с открытым исходным кодом СУБД PostgreSQL.\nУровень обработки данных # Уровень обработки данных:\nОсуществляет опрос измерительных каналов в заданном интервале времени; Преобразует полученные данные в системные и несистемные величины в соответствии с типом БД, такие как: мЗв/ч (мкР/с) или Бк/м. куб. (Ки/л); Сохраняет полученные данные с временной меткой в базу данных; Осуществляет управление свето-звуковой сигнализацией в соответствии с установленными порогами на каждом канале через канал связи АСРК; Осуществляет агрегирование данных для расчетов выбросов газа из вентсистем в заданных промежутках времени; Осуществляет агрегирование данных для отображения графиков; Осуществляет управление БД через канал связи АСРК; В качестве сервера ССОД используются промышленные компьютеры AdvantiX, но могут использоваться и менее громозкие и дорогие решения, так как требования ПО ССОД к вычислительной мощности ССОД достаточно низкие. В качестве таких решений могут выступать даже одноплатные компьютеры, типа Raspberry PI 4 или их аналоги, поддерживающие запуск х64 Linux.\nПервоначально ПО ССОД написано на C#, .net framework 4.7 под ОС Windows с графическим интерфейсом, который выступал и сервером и клиентом:\nНо на данный момент, с целью миграции на системы на базе ядра Linux, основная часть ПО сервера была переписана на C#, net core 6, и теперь является кросс-платформенным серверным решением, а клиент был выделен в отдельное desktop и web-приложение (в разработке).\nПО ССОД запускается в изолированном контейнере, который в случае непредвиденных ошибок будет автоматически перезапущен. Подход с использованием контейнеров позволяет не устанавливать зависимости на серверные машины (весь runtime включен в состав сборки) и в случае поломки позволит в кратчайшие сроки без лишних манипуляций запустить сервер на новой / резервной серверной машине.\nКонтейнеризация ПО ССОД так же обеспечивается free-open-souce ПО.\nКлиентский уровень # Desktop-клиент написан на C#, net core 6 с использованием библиотеки WPF, представляет собой средство отображения информации со всей системы, такой как:\nРезультаты измерения с БД; Состояние пороговой сигнализации и измерительных каналов; Состояние всех доступных ССОД; Графики значений по точкам контроля. Клиент позволяет:\nУстанавливать на контроль один из выбранных каналов, что позволяет в реальном времени отслеживать динамику на живом графике в нижней части клиента; Выбирать способ сортировки и отображения каналов (отображать только превышения / конкретный сервер / отказавшие каналы и др.) Внешний вид клиента:\nupd v0.0.3, добавили возможность:\nВыводить отчёт за 24/6/2 часа по выбросам с вентсистемы, спецконтролю и йодному участку; Выводить мультиканальные графики за выбранный период времени как в отдельном окне, так и в нижнюю секцию клиента; Отображать состояние серверов системы; Обновленный клиент:\nВ данный момент ведется активное расширение функционала клиента.\nВ планах # Объединенная Web-платформа # Платформа пишется на языках Ruby, JavaScript и C#, будет включать в себя комплексное решение для упрощения взаимодействия служб, упрощенный доступ до данных системы радиационного контроля, унифицирования информации, с целью упрощения доступа к ней сотрудников аутентифицированных служб.\nВсе средства используемые в разработке являются open-source решениями использующими свободные лицензии.\nWeb-клиент системы РБ # Решаемая проблема:\nСуществующий клиент требует своей установки на персональный компьютер или рабочую станцию каждому конкретному пользователю; В случае обновления существуют трудности с доставкой файлов обновления до клиента и существует вероятность непредвиденных ошибок, которые потребуют помощи специалиста; Часть пользователей могут иметь отличные от поддерживаемых операционную систему или не иметь персонального компьютера вовсе, а, например, иметь только планшет на iOS или Android =\u0026gt; пользователь не может получить оперативный доступ к данным системы радиационного контроля. Решение: WEB-клиент, входящий в состав платформы.\nЭтот клиент будет отображать графики, значения с точек контроля и состояние каналов, при этом не требуется ничего, кроме браузера, который сейчас есть на любом устройстве.\nАвторизированный доступ осуществляется только для сотрудников УРБ и / или имеющих соответствующий доступ аутентефицированнмы пользователям в режиме чтения.\nРаботы по разработке WEB-клиента уже ведутся.\nПомощник службы РБ, доз. контроль # Решаемая проблема:\nОформление допусков дозиметристом занимает много времени; При оформлении допуска дозиметристу требуется вручную расчитывать время пребывания исполнителя в требуемом помещении, исходя из параметров, полученных из системы радиационного контроля. Требуется ведение дополнительных журналов контроля дозовых нагрузок, с целью недопущения переоблучения персонала. Решение: Помощник для службы РБ, входящий в состав платформы.\nПри оформлении электронного допуска, вся требуемая информация будет автоматически расчитана и учтена из данных, полученных от системы радиационного контроля. Система также обязана учесть возможность допуска сотрудника до работ, приняв во внимание его дозовую нагрузку за установленный период времени.\nДозиметристу останется только дать своё согласие на допуск сотрудника, а по завершению работ внести набранные дозы в допуск и закрыть его. Информация о набранной дозе будет учтена в базе данных сотрудников.\nАвторизированный доступ осуществляется только для сотрудников УРБ и / или имеющих соответствующий доступ аутентефицированнмы пользователям.\nПомощник для службы ОМИТ # Решаемая проблема: В данный момент:\nсуществуют затруднения в коммуникации между отделами ОМИТ и службами, которым требуется осуществлять госповерку средств измерения при помощи ОМИТ; для отправки, получения, осуществления поверки требуется заполнять слишком много лишних бумаг; бумажные паспорта приборов быстро изнашиваются и часто могут теряться, требуют дополнительного внимание сотрудников служб ОМИТ, многие документы приходится заполнять 2 и более раз в разной форме. Решение: Система \u0026ldquo;Тикетов\u0026rdquo;, входящая в состав платформы, позволяющая создавать задачу пользователю, который осуществляет отправку прибора с меткой, в примерном виде:\nСлужба Пользователь Цель Тип Коэффицент УРБ-106 Суперинженеров Иван Демьянович Поверка БДМГ-41-01 2.4 Пользователю достаточно будет выбрать только цель отправки устройства и сам прибор, вся сотальная информация будет получена из базы данных, и передать устройство в доставку.\nИнспектор в свою очередь получит оповещение, что ему направлена задача, с возможностью просмотреть подробную информацию об устройстве, отправителе, износе направляемого устройства, предыдущих поверках и тд.\nПользователи, отправляющие прибор, смогут видеть статус поверки прибора, например:\nПринят в службе ОМИТ; Отправлен на ремонт; Продлён срок эксплуатации; Не подлежит продлению и тд. Эта часть системы работает по аналогии с канбан-доской, где создается задача и ее статус меняется пользователем по завершению какого-либо этапа работы.\nТакая система позволит:\nОтказаться от физических, бумажных паспортов средств измерения; Прогнозировать и перераспределять нагрузку на отдел ОМИТ; Сократить процент \u0026ldquo;просроченных\u0026rdquo; сроков госповерки средств измерения; Сократить процент \u0026ldquo;затерявшихся\u0026rdquo; средств измерений, отправленных на поверку; Осуществлять в автоматическом режиме подготовку нужных документов для продления сроков служб средств измерений / осуществлять продление. В индеальной картине на складах должны быть установлены сканеры QR- или штрих-кодов, для увеличения пропускной способности пунктов приема и отправки. В таком случае движение приборов отслеживается более гибко как отправителем, так и инспектором.\nАвторизированный доступ осуществляется только для сотрудников ОМИТ и / или имеющих соответствующий доступ аутентефицированнмы пользователям в режиме чтения.\nОбъединение частей систем в единый комплекс # Системы мониторинга состояний отдельных юнитов системы # Когда серверов становится больше одного, отслеживание состояний машин становится достаточно трудозатратной задачей, требующей постоянного присутствия специалиста. Современные средства позволяют осуществлять наблюдение за парком устройств в автоматическом режиме и заблаговременно оповещать о проблемах, например, об заканчивающимся месте на жестких дисках, оперативной памяти или зависании машины, перегрев и тд.\nВ качестве сервера мониторинга мы будем использовать Zabbix + Graphana. Они позволят отслеживать состояние машин, отображать в виде графиков нужную информаци, информировать о различных ошибках или изменениях отслеживаемых параметров.\nБлагодаря применению таких средств, мы сократим время простоя участков системы и увеличим отказоустойчивость. Система будет легко расширяемой не только за счет простого масштабирование серверной части ARMStrong, но и за счет систем мониторинга zabbix и graphana.\n","date":"11 December 2022","permalink":"/posts/arms-about-the-system/","section":"Posts","summary":"Познакомимся с ARMStrong, рассмотрим принципы построения и задачи, которые перед нами стоят.","title":"ARMStrong: знакомство с системой радиационного контроля"},{"content":"","date":"11 December 2022","permalink":"/tags/dev/","section":"Tags","summary":"","title":"dev"},{"content":"","date":"11 December 2022","permalink":"/categories/projects/","section":"Categories","summary":"","title":"projects"},{"content":"","date":"8 December 2022","permalink":"/tags/blog/","section":"Tags","summary":"","title":"blog"},{"content":"","date":"8 December 2022","permalink":"/tags/hugo/","section":"Tags","summary":"","title":"hugo"},{"content":"Рассмотриваем, как нам поднять, захостить и настроить деплой нашего блога не заплатив при этом ни копейки (ну или совсем чуть-чуть).\nНе нужно путать Hygge и Hugo, эти слова созвучны, но почти ничего общего не имеют, кроме того комфорта, который предоставляет Hugo во время работы с ним.\nHugo \u0026ndash; фреймворк, генератор статическиъ страниц, а Hygge \u0026ndash; датский эпитет, описывающий теплое и приятное.\nНаш уютный друг Hugo # Hugo — генератор статических html файлов. Мы, соблюдая флоу этого парня, размещаем наш текст в markdown формате и наши изображения в нужных папках, а Hugo при запуске соберут из них html странички.\nУстановка и первый старт # Первом делом идем и читаем документацию. Нам понадобится установить git и сам Hugo.\nsudo dnf update sudo dnf install git hugo В документации Hugo есть много примеров установки на MS Windows, MacOS, Linux и даже BSD. Я использую Fedora 36, так что все примеры будут из неё, но, если вы используете что-то другое, разница будет не существенной.\nДалее нам нужно инициализировать новый блог. Забегая вперед, мы будем хостить блог на GitHub pages, а для этого у нас уже должен быть аккаунт на GitHub и создан репозиторий типа \u0026lt;username\u0026gt;.github.io, это имя я буду использовать для примеров далее:\nhugo new site \u0026lt;username\u0026gt;.github.io cd \u0026lt;username\u0026gt;.github.io Нам сразу надо озаботиться тем, чтобы в репозиторий не улетали лишние файлы, так что сначала создадим файл .gitignore, в который добавим только одну запись /public:\necho \u0026#34;/public\u0026#34; \u0026gt; .gitignore И только теперь инициализируем репозиторий:\ngit init git branch -M main git remote add origin git@github.com:\u0026lt;username\u0026gt;/\u0026lt;username\u0026gt;.github.io.git В целом это все, мы сгенерировали базовый проект, который уже работает. Но мы не будем использовать дефолтный блог, погнали выбирать тему и тюнить его.\nНастаиваем тему и тюним блог # Выбираем тему, которую будем использовать в нашем блоге тут.\nМне приглянулась, например PaperMod. Почти у каждой темы есть doc-страница, демо и ссылки на репозиторий с ней. Эта не исключение, идем читать README.\nУстанавливаем тему в наш проект:\ngit submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive Теперь нужно подключить нашу тему, для этого удалим старый и создадим новый файл настроек:\nrm config.toml vim config.yml Так делать нужно не всегда: иногда достаточно отредактировать config.toml; иногда требуется следовать flow-темы и переместить config.toml в папку config. Все это описано в документации к выбранной вами теме.\nДалее скопируем из документации в файл config.yml настройки, и немного потюнем под себя:\nbaseURL: \u0026#34;https://username.github.io/\u0026#34; title: My new site paginate: 10 theme: PaperMod enableRobotsTXT: true buildDrafts: false buildFuture: false buildExpired: false minify: disableXML: true minifyOutput: true params: env: production # to enable google analytics, opengraph, twitter-cards and schema. title: ExampleSite description: \u0026#34;This is long-long description...\u0026#34; keywords: [Blog, Portfolio, PaperMod] author: My name there images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] DateFormat: \u0026#34;January 2, 2006\u0026#34; defaultTheme: auto # dark, light disableThemeToggle: false ShowReadingTime: true ShowPostNavLinks: true ShowCodeCopyButtons: true ShowWordCount: true ShowRssButtonInSectionTermList: true UseHugoToc: true disableSpecial1stPost: false disableScrollToTop: false hidemeta: false hideSummary: true showtoc: false tocopen: false assets: favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags # home-info mode homeInfoParams: Title: \u0026#34;Hi there \\U0001F44B\u0026#34; Content: Welcome to my blog socialIcons: - name: twitter url: \u0026#34;https://twitter.com/\u0026#34; - name: stackoverflow url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/\u0026#34; cover: hidden: true # hide everywhere but not in structured data hiddenInList: true # hide on list pages and home hiddenInSingle: true # hide on single page # for search # https://fusejs.io/api/options.html fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] menu: main: - identifier: categories name: categories url: /categories/ weight: 10 - identifier: tags name: tags url: /tags/ weight: 20 - identifier: example name: example.org url: https://example.org weight: 30 pygmentsUseClasses: true markup: highlight: noClasses: false # anchorLineNos: true # codeFences: true # guessSyntax: true # lineNos: true # style: monokai Можем даже уже проверить, что у нас получается:\nhugo server По пути 0.0.0.0:1313 или localhost:1313 станет доступен наш блог.\nПо поводу детальной настройки темы читаем в документации к самоей теме.\nСоздаем первую запись в блоге # Теперь попробуем разобраться, как нам добавлять новые статьи на наш сайт.\nПо сути наши статьи это всего лишь markdown-файлы, которые мы помещаем в папку, например, posts/my_new_awesome_post, а далее Hugo конвертирует их в .html странички.\nСоздадим для начала папку для нашей статьи:\nmkdir -p content/posts/first-post vim content/posts/first-post/index.md Поместим туда шаблон статьи и что-то напишем:\n--- title: \u0026#34;My 1st post\u0026#34; date: 2022-12-08T11:30:03+00:00 tags: [\u0026#34;first\u0026#34;] author: \u0026#34;Me\u0026#34; showToc: true TocOpen: false draft: false hidemeta: false comments: false description: \u0026#34;Desc Text.\u0026#34; canonicalURL: \u0026#34;https://canonical.url/to/page\u0026#34; disableHLJS: true # to disable highlightjs disableShare: false disableHLJS: false hideSummary: false searchHidden: true ShowReadingTime: true ShowBreadCrumbs: true ShowPostNavLinks: true ShowWordCount: true ShowRssButtonInSectionTermList: true UseHugoToc: true cover: image: \u0026#34;\u0026lt;image path/url\u0026gt;\u0026#34; # image path/url alt: \u0026#34;\u0026lt;alt text\u0026gt;\u0026#34; # alt text caption: \u0026#34;\u0026lt;text\u0026gt;\u0026#34; # display caption under cover relative: false # when using page bundles set this to true hidden: true # only hide on current single page editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link --- # Заголовок ## Второй заголовок Какой-то __жирный__ текст, который зачем-то _наклонили_. Проверим, что у нас там в блоге теперь:\nПоговорим подробнее, что мы сейчас сделали:\nМы создали в директории content директорию posts и вложили туда директорию для нашей статьи first-post; Создали в директории first-post файл index.md. Hugo всегда первым делом будет искать файл index.md, а за адрес до статьи будет принимать путь \u0026lt;category_dir\u0026gt;/\u0026lt;post_name_dir\u0026gt;/. В файл index.md закинули расширенную конфигурацию поста. Конфигурация поста всегда распологается в шапке файла между символами --- ---.\nПример базовой конфигурации в code-блоке ниже.\n--- title: \u0026#34;\u0026lt;Title\u0026gt;\u0026#34; date: \u0026lt;datetime\u0026gt; # \u0026lt;YYYY-mm-dd\u0026gt;T\u0026lt;HH:MM:ss\u0026gt;\u0026lt;+/-UTC\u0026gt; draft: true # or false --- Несем проект до хостинга и автоматизируем деплой # Мы сгенерировали сайт, добавили в него кастомную тему, даже пост какой-никакой написали. Все классно, но блог пока доступент только на вашей машине. Сделаем его общедоступным.\nПрокидываем секреты # Для автоматической развёртки на GitHub Pages требуется сгенерировать ключи, а точнее так называемые \u0026ldquo;секреты\u0026rdquo;.\nЕсли у вас не был настроен git, то прокинем сначала имя и email:\ngit config --global user.name \u0026#34;\u0026lt;Your Name\u0026gt;\u0026#34; git config --global user.email \u0026#34;\u0026lt;Your Email\u0026gt;\u0026#34; Генерируем ключи для деплоя:\nssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f deployment -N \u0026#34;\u0026#34; Заходим на GitHub в наш репозиторий (он пока еще пустой, мы в него ничего не пушили). Далее идем Settings ⇒ Deploy Keys ⇒ Add Deploy Keys.\nДобавляем сюда ваш публичный ключ. Скопировать его можно из только что сгенерированного файла:\ncat deployment.pub ssh-rsa AASdas...KTTx2lOvqFvqOMAIw== \u0026lt;your_email\u0026gt;@proton.com Скопировать фразу нужно целиком. Назовем его public key of ACTIONS_DEPLOY_KEY.\nДалее идем в Secrets ⇒ Actions ⇒ New Repository Secret. Вставляет туда приватный ключ:\ncat deployment Также копируем фразу целиком от и до, называем ключ ACTIONS_DEPLOY_KEY.\nЧто бы скопировать что-то из терминала используйте хоткей CTRL + Shift + C.\nЕсли хочется совсем обойтись без мыши, то установите screen. Как пользоваться screen в этом ответе.\nНастраиваем actions и пушим # В корне нашего блога создаем директории:\nmkdir -p .github/workflows В workflows создадим файл gh-pages.yml:\nvim .github/workflows/gh-pages.yml Скопируем туда это:\nname: GitHub Pages on: push: branches: - main jobs: build-deploy: runs-on: ubuntu-latest concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - name: Checkout uses: actions/checkout@v3 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_branch: gh-pages publish_dir: ./public Наконец-то пушим наш блог в удаленный репозиторий и ждем ошибок, потому что мы не настроили еще одну вещь:\ngit add . \u0026amp;\u0026amp; git commit -m \u0026#34;Init\u0026#34; \u0026amp;\u0026amp; git push -u origin main Идем в наш репозиторий и скорее всего там нифига не завелось, потому что не настроена ветка из которой деплоится сайт. Идем в Settings ⇒ Pages ⇒ Build and deployment.\nВ Source устанавливаем параметр Deploy from a branch и выбираем Branch, из которой будем деплоится gh-pages.\nИзменим что-нибудь в нашей тестовой статье и повторим пуш. Если деплой прошел успешно, то ваш блог станет доступен по адресу \u0026lt;username\u0026gt;.github.io.\nSay my name!.. Используем свой домен # Мы задеплоили, все настроили, но нам хочется припарковать свой домен или же купить его для начала.\nКупить домен можно где угодно. Я сам покупал на https://beget.com/ru/domains. Никаких рефералок у меня нет, увы, но там и без того самые дешевые домены в .com зоне. В .com зоне можно покупать домены не указывая паспортные данные, а в .ru нужно будет предоставлять паспорт.\nПредставили, что мы арендовали домен. Че дальше с ним делать?\nДля начала идем в панель управления вашим доменом у вашего регистратора, проходим в настроики DNS и добавляем записи типа А и AAAA. IP-адреса берем здесь. Не забываем удалить старый IP-адрес, который был дефолтным от регистратора.\nДалее настраиваем поддомен www. Добавим для него запись типа CNAME, который будет указывать на ваш зарегистрированный домен, таким образом будет происходит переадресация.\nДалее идем в корень нашего проекта и создаем там в папке static файл CNAME и кладем в него наш домен:\necho \u0026#34;\u0026lt;yourdomen.com\u0026gt;\u0026#34; \u0026gt; static/CNAME Теперь пушим в репозиторий изменения и идем рассказывать GitHub’у, что мы хотим использовать свой домен. Идем в репозиторий ⇒ Settings ⇒ Pages ⇒ секция Custom domain. Вписываем туда свой apex-домен (\u0026lt;yourdomen.com\u0026gt;) и нажимаем save. Домен должен проходить все проверки и GitHub самостоятельно подключит к нему tls-сертификаты.\nПишем свои кастомные Shortcode # Shortcode \u0026ndash; это специальная разметка, которую сможет понять Hugo и отобразить вам соответствующий результат после рендера.\nПредставим, что у нас появилась задача, которая шире, чем функционал выбранной вами темы. Например я захотел добавить на страницу карточку с моей музыкой, но ни у Hugo, ни у выбранной темы нет шорткода, что бы вставить карточку трека с bandcamp.com.\nВозникнет резонный вопрос: почему не вставить просто html в текст .md страниц?\nВопрос хороший. Также хороший вопрос, почему Hugo не позволяет так делать. Он выдасл на это действие ошибку и не сможет собрать нам страницу. Не беда, напишем свой кастомный шорткод.\nДля начала определимся, как мы хотим использовать его в тексте нашей статьи.\nПосмотрим на ссылку, которая ведет до нашего альбома, например:\n\u0026lt;domain\u0026gt;/EmbeddedPlayer/album=4206660389/size=large/bgcol=ffffff/... Изменяться у нас будет только album=4206660389, примем этот параметр как \u0026lt;type\u0026gt;=\u0026lt;id\u0026gt;. А использовать в разметке будем как:\n{{\\\u0026lt; bandcamp id=\u0026#34;\u0026lt;id\u0026gt;\u0026#34; type=\u0026#34;\u0026lt;type\u0026#34;\u0026gt; \\\u0026gt;}} Здесь и далее для этого шорткода я экранировал знаки \u0026lt; и \u0026gt; иначе он сработает =) С этим определились, теперь накидаем простенький шорткод. Для это создадим файл нашего шорткода bandcamp.html в layouts/shortcodes.\nlayouts └── shortcodes └── bandcamp.html Определим 2 переменные, в которые мы получаем значения и 1 логическую конструкцию:\n{{- $id := .Get \u0026#34;id\u0026#34; -}} {{- with .Get \u0026#34;type\u0026#34; -}} {{- if eq . \u0026#34;track\u0026#34; -}} \u0026lt;div style=\u0026#34;margin: 0px 10px 10px 10px;;\u0026#34;\u0026gt; \u0026lt;iframe style=\u0026#34;border: 0; width: 350px; height: 350px;\u0026#34; src=\u0026#34;https://bandcamp.com/EmbeddedPlayer/track={{ $id }}/size=large/bgcol=333333/linkcol=9a64ff/minimal=true/transparent=true/\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; {{- else if eq . \u0026#34;album\u0026#34; -}} \u0026lt;div style=\u0026#34;margin: 0px 10px 10px 10px;\u0026#34;\u0026gt; \u0026lt;iframe style=\u0026#34;border: 0; width: 350px; height: 350px;\u0026#34; src=\u0026#34;https://bandcamp.com/EmbeddedPlayer/album={{ $id }}/size=large/bgcol=333333/linkcol=9a64ff/minimal=true/transparent=true/\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} {{- end -}} Вот этот кусок кода я беру с шаринг тулс бендкампа:\n\u0026lt;iframe style=\u0026#34;border: 0; width: 350px; height: 350px;\u0026#34; src=\u0026#34;https://bandcamp.com/EmbeddedPlayer/track={{ $id }}/size=large/bgcol=333333/linkcol=9a64ff/minimal=true/transparent=true/\u0026#34;\u0026gt; \u0026lt;/iframe\u0026gt; В нем я просто изменил захардкоженный id на свою переменную.\nНикаких дополнительных проверок делать не будем, чтобы не усложнять.\nДополнительно про кастомные шорткоды можно почтитать тут.\nДобавляем кастомные страницы # Теперь нам понадобилось добавить свою страницу, на которой будем рендерить какой-то кастомный контент. Например это страница с музыкой, на которой будут рендериться карточки с музыкой. Как нам добавить страничку и кнопку в меню?\nСоздаем директорию music в content, и помещаем туда файл index.md.\ncontent └── music └── index.md В index.md расскажем Hugo, что это новый слой и сразу воспользуемся нашим новым кастомным шорткодом:\n--- title: \u0026#34;Music\u0026#34; Description: \u0026#34;Music page\u0026#34; layout: \u0026#34;music\u0026#34; --- {{\\\u0026lt; bandcamp id=\u0026#34;3756810824\u0026#34; type=\u0026#34;track\u0026#34; \\\u0026gt;}} {{\\\u0026lt; bandcamp id=\u0026#34;1062007976\u0026#34; type=\u0026#34;album\u0026#34; \\\u0026gt;}} Далее нам нужно добавить сам слой в layouts. Создаем директорию page и кладём туда файл music.html.\nlayouts ├── page │ └── music.html └── shortcodes └── bandcamp.html Очень похоже на то, как мы добавляли шорткод.\nДалее пишем разметку страницы в music.html:\n{{ define \u0026#34;main\u0026#34; }} \u0026lt;!-- Main Content --\u0026gt; \u0026lt;main id=\u0026#34;main-content\u0026#34; class=\u0026#34;grow\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1 class=\u0026#34;mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral\u0026#34;\u0026gt;Music\u0026lt;/h1\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;section class=\u0026#34;flex flex-wrap -mx-2 place-content-center overflow-hidden\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container my-3\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;flex flex-wrap\u0026#34;\u0026gt;{{ .Content }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/main\u0026gt; {{ end }} Снова видим обёртку html в специфический синтаксис.\nТеперь остается рассказать нашей теме о том, что появилась новая кнопка в NavBar.\nИдем в конфигурационный файл вашей темы (в зависимости от темы его расположение будет отличаться), находим секцию с настройкой вашего меню и указываем ссылку на нашу страницу. Будет что-то вроде такого:\n[[main]] name = \u0026#34;Music\u0026#34; pageRef = \u0026#34;music\u0026#34; weight = 20 Все готова. Шаблон для странички написан, сама страница добавлена в контент и в конфигурационном файле мы сделали ссылку на нашу новую страницу.\nМожно посмотреть на примерный результат:\nУпрощаем сохранение и отправку изменений в блог # Финишная прямая. Делаем управление блогом чуточку удобнее.\nСделаем alias для сохранения и пуша изменений. Я использую oh-my-zsh, но для bash настройка будет аналогичная, только вместо .zshrc будет .bashrc.\nОткроем файл настроек нашего шелла:\nvim ~/.zshrc В самый конец файла дописываем строку:\nalias post-save=\u0026#34;git add . \u0026amp;\u0026amp; git commit -m \\\u0026#34;Added new post\\\u0026#34; \u0026amp;\u0026amp; git push\u0026#34; Перечитываем файл настроек, что бы изменения вступили в силу:\nsource ~/.zshrc Теперь, когда мы внесли какие-то изменения в настройки, например, или добавили статью мы можем выполнить, будучи в корневой папке блога:\npost-save И все, изменения полетят на GitHub, где все задеплоится и через пару секунд изменения отобразятся на вашем сайте.\nБлагодарности серому волшебнику # Если текст был полезен и ты не можешь усмирить желание быть благодарным, то вот мои кошелечки (USDT и TRX кошельки одинаковые, да, это не ошибка):\nTether (TRC-20, USDT):\nTYvFYUV3h5HwqfyTxskGQK7nDbUHTcwPn2 Tron (TRX):\nTYvFYUV3h5HwqfyTxskGQK7nDbUHTcwPn2 Monero (XMR):\n4AbxbT9vrNQTUDCQEPwVLYZq2zTEYzNr9ZzTLaq9YcwVfdxwkWjZ6FsewuXVDXPk7x2rE6FZACmLePPgJEcY4rm1GSHkwTZ ","date":"8 December 2022","permalink":"/posts/hugo-simple-blog/","section":"Posts","summary":"Рассмотриваем, как нам поднять, захостить и настроить деплой нашего блога не заплатив при этом ни копейки (ну или совсем чуть-чуть).","title":"Уютный блог на Hugo + GitHub Page"},{"content":"Рассказываю, как ARMStrong расчитывает выбросы через вентсистему и строит из них отчёты.\nКонтроль, контроль и еще раз контроль! Смотрим, какое количество активных газов мы выбрасываем, оцениваем их вес и формируем отчеты. Внимание! Спасибо за внимание. Введение # На атомных, хим и металлургических предприятиях всегда требуется контроль за уровнем выхода активных веществ, которое сбрасывает предприятие. Эти уровни устанавливаются нормативными актами и не должны быть превышены.\nНа различных предприятиях отчетность ведётся по-разному, мы же разберем случай, когда есть оперативный контроллирующий персонал, который должен заносить запись об контроллируемой обстановке в оперативный журнал каждые n часов, в начале смены или же посуточно.\nДля этих целей был разработан небольшой модуль для клиента ARMStrong, который и будет формировать отчетность по выбрасываемым газам, средней активности на МЭД-точках контроля и \\(I_{131}\\)-участке.\nРассчитываем выбросы # Для справки: каждая точка представляет собой объект из истории измерений, который имеет три свойства: Id, SystemEventValuem и EventDateTime. public class History { public int Id { get; } public double SystemEventValue { get; } public DateTime EventDateTime { get; } } Что бы вычислить, сколько Бк было выброшено, нам нужно знать значение на момент начала расчёта, продолжительность выброса и значение на момент окончания расчёта. Значение на момент начала и окончания расчёта мы принимаем за \\(N_1\\) и \\(N_2\\) соответственно.\nЗа продолжительность выброса мы возьмем \\(\\Delta T\\), которая является просто разницей по времени между второй и первой точкой.\nТаким образом для вычисления выброса нам требуется две точки и выброс будет расчитываться как:\n\\(S = \\dfrac{N_1 + N_2}{2} \\Delta T\\)\nСреднее по этим точкам мы берем по причине, что не представляется возможным предугадать, в какой момент времени между двумя соседними точками начался рост или спад. Минимальное время регистрации можно устанавливать в 2.5 секунды, но ввиду особенности блоков детектирования типа БДГБ-02П и подобных сокращать окно практически бессмысленно, это не приводит к увеличению точность.\nДалее, чтобы вычислить суммарный расход, нужно просто просуммировать все результаты и умножить на расход по вентсистеме точки контроля.\nРасход хранится в формате \\(\\dfrac{м^3}{час}\\), поэтому требуется привести его к \\(\\dfrac{м^3}{сек}\\), для этого просто разделим его на 3600.\nУчитывая вышесказанное мы можем вывести формулу расчета выбросов и применить её в коде клиента:\n\\(S_{sum} = (\\sum{\\dfrac{N_1 + N_2}{2} \\Delta T}) C_{sec} \\), где:\n\\(S_{sum}\\) \u0026ndash; суммарный выброс по точке контроля, \\(Бк\\); \\(\\dfrac{N_1 + N_2}{2}\\) \u0026ndash; среднее значение по двум точкам, \\(\\dfrac{Бк}{м^3}\\) \\(\\Delta T\\) \u0026ndash; длительность выброса \\(T_2 - T_1\\), \\(сек.\\); \\(C_{sec}\\) \u0026ndash; расход газа через вентсистему точки контроля \\(\\dfrac{C_{hour}}{3600}\\), \\(\\dfrac{м^3}{сек}\\). Метод для расчета выбросов будет следующим:\npublic double GetSystemBlowout(List\u0026lt;History\u0026gt; histories, Channel channel) { double summaryBlowout, rawBlowoutSumm = 0; for (int i = 0; i \u0026lt; histories.Count - 1; i++) { DateTime firstPointDateTime = histories[i].EventDate; DateTime secondPointDateTime = histories[i + 1].EventDate; double deltaT = secondPointDateTime .Substract(firstPointDateTime) .TotalSeconds; double firstPointValue = histories[i].SystemEventValue; double secondPointValue = histories[i + 1].SystemEventValue; dobule averageValue = (firstPointValue + secondPointValue) / 2; rawBlowoutSumm += averageValue * deltaT; } double consumprion = channel.ChannelConsumption / 3600; summaryBlowout = rawBlowoutSumm * consumption; return summaryBlowout; } Группируем выбросы по категориям # На данный момент группы были захардкодены, и выглядит это следующим образом:\nprivate void SetBlowoutReportCategory() { int V1id = 275, V2id = 276, V3id = 277, V4id = 278, V4_id = 279, V5id = 280, V6id = 281, V7id = 282; int[] categoryI = new int[] { V1id, V7id }; int[] categoryII = new int[] { V2id, V3id, V4_id, V5id }; int[] categoryIII = new int[] { V6id }; if (categoryI.Contains(Channel.Id)) { BlowoutReportCategory = (int)BlowoutCategory.I; } else if (categoryII.Contains(Channel.Id)) { BlowoutReportCategory = (int)BlowoutCategory.II; } else if (categoryIII.Contains(Channel.Id)) { BlowoutReportCategory = (int)BlowoutCategory.III; } } Изначально немного неверно были спроектированы модели, мы отталкивались от существующей базы данных и в будущем будем это исправлять, ну а пока говнокодим хардкодим и проверяем как работает.\nВ коде выше мы просто отсортировали каналы по категориям. ID-каналов мы указали руками, какой в какую категорию должен отправляться, это тоже неверное, так делать нельзя но нам льзя.\nТеперь можно посчитать суммарную активность по категориям:\nprivate void StartReport() { int V1 = 275, V2 = 276, V3 = 277, V4 = 278, V4_ = 279, V5 = 280, V6 = 281, V7 = 282; int[] blowoutGroup = new int[] { V1, V2, V3, V4, V4_, V5, V6, V7 }; //... var I = new Channel() { ChannelName = \u0026#34;Категория I\u0026#34;, SystemEventValue = BlowoutReport .Where(x =\u0026gt; x.BlowoutReportCategory == 1) .Sum(x =\u0026gt; x.BlowoutSystemValue), NotSystemEventValue = BlowoutReport .Where(x =\u0026gt; x.BlowoutReportCategory == 1) .Sum(x =\u0026gt; x.BlowoutNotSystemValue) }; var II = new Channel() { ChannelName = \u0026#34;Категория II\u0026#34;, SystemEventValue = BlowoutReport .Where(x =\u0026gt; x.BlowoutReportCategory == 2) .Sum(x =\u0026gt; x.BlowoutSystemValue), NotSystemEventValue = BlowoutReport .Where(x =\u0026gt; x.BlowoutReportCategory == 2) .Sum(x =\u0026gt; x.BlowoutNotSystemValue) }; var III = new Channel() { ChannelName = \u0026#34;Категория III\u0026#34;, SystemEventValue = BlowoutReport .Where(x =\u0026gt; x.BlowoutReportCategory == 3) .Sum(x =\u0026gt; x.BlowoutSystemValue), NotSystemEventValue = BlowoutReport .Where(x =\u0026gt; x.BlowoutReportCategory == 3) .Sum(x =\u0026gt; x.BlowoutNotSystemValue) }; var summ = new Channel() { ChannelName = \u0026#34;Суммарная\u0026#34;, SystemEventValue = I.SystemEventValue + II.SystemEventValue + III.SystemEventValue, NotSystemEventValue = I.NotSystemEventValue + II.NotSystemEventValue + III.NotSystemEventValue, }; CategoryBlowoutBindingCollection = ReportsCollectionSingleton.GetInstance().CategoryCollection; CategoryBlowoutBindingCollection.Clear(); CategoryBlowoutBindingCollection.Add(I); CategoryBlowoutBindingCollection.Add(II); CategoryBlowoutBindingCollection.Add(III); CategoryBlowoutBindingCollection.Add(summ); } Тут все просто, суммируем по группе и все: \\(S_{cat} = \\sum N\\)\nДа, это некрасиво и очень неудобно, но для того, что бы проверить, как это работает \u0026ndash; сойдет. В будущем ID-каналов и группы будут вынесены во внешний файл настроек.\nИз пояснений стоит сказать, что мы немного схитрили и используем объект канала, что бы вывести расчеты по группам в таблицу отчётов. Это в нашем случае удобно, что бы не плодить новые сущности, но нарушает концепцию и заводит в заблуждение других разработчиков. В будущем, возможно, над этим стоит поразмыслить.\nРассчитываем среднее по МЭД и йодному участку # Мы на финишной прямой! Осталось совсем немного \u0026ndash; посчитать среднее по точкам контроля, которые следят за МЭД, т.е. за мощностью эквивалентной дозы и посчитать среднее по йодному участку.\nПриступим!\nСреднее считаеть будем просто: \\(S_{avg} = \\dfrac{N_1 + N_2 + N_n}{n}\\)\nДля удобства сделаем человеко-читаемые нотации категорий и типов блоков:\nenum DeviceType : int { EquivalenDoseRate = 1, GasVolumetricActivity, AerosolVolumetricActivity, Impulses }; enum Category : int { SpecialControl = 1, Blowout, Aerosol, Impulses }; Наполняем объект отчёта:\npublic Report(int id, DateTime startDateTime) { //... switch (Channel.DeviceType) { case (int)DeviceType.EquivalenDoseRate: ReportCategory = (int)Category.SpecialControl; AverageNotSystemValue = UnitConverter.Convert(type: (int)DeviceType.EquivalenDoseRate, value: AverageSystemValue); break; case (int)DeviceType.AerosolVolumetricActivity: ReportCategory = (int)Category.Aerosol; AverageNotSystemValue = UnitConverter.Convert(type: (int)DeviceType.AerosolVolumetricActivity, value: AverageSystemValue); break; default: AverageNotSystemValue = AverageSystemValue; break; } //... } Сам метод, который считает среднее, просто обычные LINQ-запросы:\nprivate double GetAverageSystemValue() =\u0026gt; ReportHistories.Any() ? ReportHistories.Average(avg =\u0026gt; avg.SystemEventValue) : 0; Отображаем пользователю отчёт # Код view-страниц показывать не буду, потому что там просто размечены таблицы и все. Там нет ничего сложного или непонятного:\nБерем объект отчёта Выводим в таблицу только то, что хотим видеть из него Мы рассчитали выбросы, посчитали МЭД и йод, теперь настало время показать пользователю то, что мы насчитали.\nОтображать отчёты будем в виде таблиц с эспандером, которым будут закрыты все лишние таблицы, что бы не отвлекали.\nПользователю будет предложен выбор интервала, за который он хочет получить отчет:\nДалее будет собран и отображен сам отчёт:\nВ планах # Добавить файл настроек, в котором можно будет перечислять группы и параметры, по которым будет происходить сборка отчетов; Добавить возможность вывода отчёта в файл и/или отправка отчёта по почте. ","date":"6 November 2022","permalink":"/posts/arms-blowout-report/","section":"Posts","summary":"Рассказываю, как ARMStrong расчитывает выбросы через вентсистему и строит из них отчёты.","title":"ARMStrong: отчет по выбросам"},{"content":"","date":"6 November 2022","permalink":"/tags/report/","section":"Tags","summary":"","title":"report"},{"content":"","date":"19 July 2022","permalink":"/tags/linux/","section":"Tags","summary":"","title":"linux"},{"content":"","date":"19 July 2022","permalink":"/tags/python/","section":"Tags","summary":"","title":"python"},{"content":"Рассмотрим, как демонизировать наше python-приложение под Linux.\nДьявол в деталях # В начале сотворил он небо и землю На второй день разделил он свет и тьму\n\u0026hellip;\nНа седьмой день разобрался он с systemd, запустил в фоне службы, автоматизирующие процессы, и больше никогда не был online.\nПривет-привет, оклахома кидс! В этой заметке мы будем разбираться, что нужно делать дальше, когда мы написали приложение и у нас есть сервер.\nК сожалению, недостаточно просто выгрузить приложение на удаленный сервер и запустить скрипт, например так:\nPython3 ~/MyFirstDeploy/best_fucking_idea.py Приложение запустится и даже будет работать. Но есть одно но: после того, как вы вышли с сервера, закрыв ssh-соединение, вы закрыли все запущенные вами приложения в этой сессии, в том числе и запущенный скрипт, потому что вы закрыли не только ssh-соединение, а вообще закрыли сессию, которая была создана для этого пользователя.\nЧто бы такого не происходило приложение требуется демонизировать и вынести его выполнение за рамки конкретного пользователя. Это можно сделать как средствами операционной системы (этот метод описан в этой заметке), так и запрограммировать руками (но это пипец какой костыль, не находите?)\nВ операционных системах на базе Linux организация пользователей координально отличается от Windows. Это является сильной стороной Linux-base систем и одновременно с этим, по первости, добавляет нам проблем в копилку непонимания и ахуевания, но освоившись вы почувствуете все приемущества такого подхода к разграничению пользователей.\nКстати, благодаря такому подходу к организации пользователей в Linux-base системах и появился Docker, который стал стандартом дефакто в современном мире web-разработки, привнеся в неё контейнеризацию, которая позволяет в 1 клик поднять огромный сервис на тысячах машинах, а вторым кликом почти мгновенно масштабировать мощности сервиса. В операционных Linux-base системах все привычные в windows службы (service) называют демонами (daemon). Здесь и дальше под словом демон я буду подразумевать службу, которая выполняется в фоновом режиме.\nДемон (daemon) — это всего лишь компьютерная программа, которая под управлением систем инициализации блоков способна запускать процессы в фоновом режиме. И для того, чтобы наше приложение могло запускаться в виде демона / быть демоном, его нужно демонизировать. Этим мы и займёмся дальше, но сначала мы обратим внимание на заголовок статьи. Причём тут какой-то systemd?\nSystemd — это системный диспетчер. Аналогию можно провести с диспетчером задач, который является частью менеджера процессов в windows. Этот парень позволяет нам управлять почти всеми демонами в нашей операционной системе, помогает создавать конфигурации этих демонов и прч. Не все операционные системы на базе Linux используют systemd, так что это нужно учитывать. Systemd в свою очередь работает с помощью systemctl.\nSystemctl — это инструмент центрального управления для контроля системы инициализациии. С помощью этого парня мы будем запускать, останавливать и проверять статус нашего процесса.\nВводную получили, поехали стучать по клавишам!\nМой лучший друг — демон # Итак, у нас было:\nПриложение на Python Сервер на linux с systemd Огромное желание что-то запускать Я буду использовать свой droplet на digital ocean, вы можете использовать хоть виртуальную машину на своём компьютере, разницы 0.\nИтак, мы зашли по ssh на наш сервер, предварительно загрузили на этот сервер файлы приложения, например по этому пути:\n/root/telegram-bot И нам нужно, чтобы запускался скрипт [bot.py](http://bot.py). Это точка входа в наше приложение.\nПолучаем такой путь до нашей точки входа: /root/telegram-bot/bot.py. Этот путь я буду дальше использовать для примеров.\nДля того, что бы создать демона нашего скрипта, требуется сделать ряд вещей:\nСоздать файл \u0026lt;name\u0026gt;.service, в котором будет описана конфигурация нашего демона Попросить systemctl перечитать все файлы настроек демонов Рассказать systemctl о нашем демоне (создаст semilink) Запустить демона! План понятен и приятен. Но где вообще живут эти демоны и чёэтатакое?!\nЗаходим на наш сервер:\nssh \u0026lt;user\u0026gt;@\u0026lt;server_ip_address\u0026gt; Идем смотреть на демонов:\ncd /etc/systemd/system/ \u0026amp;\u0026amp; ls -lah ./ И видим примерно следующую картину:\ndrwxr-xr-x 21 root root 4.0K May 6 08:43 . drwxr-xr-x 6 root root 4.0K May 6 05:50 .. ... drwxr-xr-x 2 root root 4.0K May 6 05:50 sshd-keygen@.service.d lrwxrwxrwx 1 root root 31 Jan 31 22:28 sshd.service -\u0026gt; /lib/systemd/system/ssh.service drwxr-xr-x 2 root root 4.0K Jan 31 22:28 sysinit.target.wants lrwxrwxrwx 1 root root 35 Jan 31 22:26 syslog.service -\u0026gt; /lib/systemd/system/rsyslog.service drwxr-xr-x 2 root root 4.0K Jan 31 22:28 timers.target.wants lrwxrwxrwx 1 root root 41 Jan 31 22:28 vmtoolsd.service -\u0026gt; /lib/systemd/system/open-vm-tools.service Файлы \u0026lt;name\u0026gt;.service — описание демона. Там лежит вся его настройка\nПапки \u0026lt;name\u0026gt;.service.d — это папка, в которой лежит дополнительная настройка демона. По умолчанию она не создается, но мы в нашем примере будем её создавать и положим туда часть настройки демона.\nСоздадим новый файл конфигурации демона для нашего приложения.\nСоздаём конфигурацию демона # Без лишних слов, будучи в папке /etc/systemd/system/\nvim bot.service Откроется редактор [VIM](https://www.vim.org/), в котором мы будем описывать нашего демона:\n[Unit] Description=My telegram bot After=multi-user.target [Service] Type=simple Restart=always ExecStart=/usr/bin/python3 /root/telegram-bot/bot.py [Install] WantedBy=multi-user.target Вот в целом - то и всё. После обновления systemctl можно запустить сервис. Но мы разберемся немного подробнее, за что отвечает каждый ключ в каждой секции.\nСекция Unit:\nDescription — Просто описание вашего сервиса, которое будет выведено при выполнении systemctl status \u0026lt;name\u0026gt; в статус-строке, после названия демона. Может быть вообще произвольным. After — Определяет порядок запуска блоков. Здесь multi-user.target указывает на цель, в которой описаны другие службы. Т.е. наш демон запустится только после того, как все службы, указанные в multi-user.target были успешно запущены. Например, в multi-user.target важные системные службы, такие как NetworkManager (NetworkManager.service) или D-Bus (dbus.service) и инструкция запуска другого целевого блока с именем basic.target. Секция Service:\nType — Настраивает тип демона, этот ключ на прямую влияет на то, как будет выполняется инструкция в ExecStart. simple — Значение по умолчанию. Процесс начинается с инструкции ExecStart и является основным процессом forking — Процесс начинается с ExecStart и порождает дочерний процесс, который замещает собой родительский процесс. oneshot — аналогичен simple, только процесс завершается до запуска последующих блоков. \u0026hellip; и т.д. Ссылку на описание всех ключей оставлю ниже. Нас же интересует только simple. Restart — Указывает на то, будет ли перезапущена служба после завершения процесса. Указываем always, что бы не быть неприятно удивленными каким-нибудь вечером. ExecStart — Инструкция, которая исполнится при запуске демона. В данном примере я указал абсолютные пути до Python и до моего скрипта, который является точкой входа в приложение. Можно упростить до python3 /root/telegram-bot/bot.py, но лучше перестраховаться на случай, если на сервере не прокинуты $PATH. Секция Install:\nWantedBy — указывает на зависимости, причем делает это мягче, чем ключ RequareBy, который бы прервал выполнение, в случае неудачного запуска одной из служб. Описание всех ключей тут.\nПрячем от чужих глаз чувствительные данные # Бывает такое, что приложение использует какие-то пароли / ключи / токены и тд, которые не стоит держать в открытом виде в скрипте или где-то рядом с ним, что бы случайно не выгрузить на github в публичный репозиторий. В таком случае можно восппользоваться переменными окружения или Environment variable.\nТак как наше приложение будет запущено в качестве демона, то нельзя просто так прокинуть эти переменные, допустим, пользователю root. Мы будем использовать дополнительную настройку нашего демона, в которой переопределим этот блок (вспоминаем про папки \u0026lt;name\u0026gt;.service.d)\nДля этого воспользуемся аргументом edit у systemctl и создадим для нашей настройки bot.service доп настройку с нашими переменными окружения:\nsystemctl edit bot.service Откроется редактор nano с пустым файлом. Внесем туда свои переменный, переопределив блок [Service]:\n[Service] Environment=\u0026#34;telegram=\u0026lt;your_token\u0026gt;\u0026#34; Environment=\u0026#34;openweathermap=\u0026lt;your_token\u0026gt;\u0026#34; Environment=\u0026#34;resources_path=/root/telegram-bot/resources\u0026#34; Далее нажимаем Ctrl + O, чтобы записать наш файл на диск, назовем его local.conf, и нажимаем Ctrl + X для выхода.\nМожем проверить, что у нас получилось:\n. ├── bot.service ├── bot.service.d │ └── local.conf Видим наш файл настройки bot.service и дополнительная конфигурация local.conf в папке bot.service.d.\nТеперь при запуске службы будут подтянуты переменные окружения и ваш код приложения, который требовал эти самые environment variable будет отрабатывать как положено.\nЗапускаем и проверяем статус нашего демона # Мы сделали все нужные настройки, теперь надо рассказать нашему systemctl о нашем демоне, добавить его в автозапуск и запустить наконец-то.\nОбновляем информацию о демонах:\nsystemctl daemon-reload Добавляем в автозагрузку:\nsystemctl enable bot.service Запускаем:\nsystemctl start bot.service Проверим статус, запустился ли вообще сервис или упал:\nsystemctl status bot.service Должны увидеть вот такое сообщение:\n● bot.service - My telegram bot Loaded: loaded (/etc/systemd/system/bot.service; enabled; vendor preset: enabled) Drop-In: /etc/systemd/system/bot.service.d └─local.conf Active: active (running) since Fri 2022-05-06 09:17:11 UTC; 24h ago ... Если в статусе Failed, значит либо что-то с приложением, либо что-то с настройкой. Можно пойти почитать логи коммандой [dmesg](https://manpages.org/dmesg) или cat /var/log/syslog.\nПолезные ссылки # Простейший способ превратить скрипт в демона, Linkolnloop, Graham King Руководство для начинающих по systemctl, BitLaunch Использование Systemctl для управления системой и юнитами, библиотека Digital Ocean Управление службами с помощью systemd, документация Red Hat Описание всех ключей файла конфигурации службы, документация Red Hat Как создать и удалить символическую ссылку, freecodecamp, Dillion Megida Как читать и устанавливать переменные среды и shell в Linux, библиотека Digital Ocean Благодарности серому волшебнику # Если текст был полезен и ты не можешь усмирить желание быть благодарным, то вот мои кошелечки (USDT и TRX кошельки одинаковые, да, это не ошибка):\nTether (TRC-20, USDT):\nTYvFYUV3h5HwqfyTxskGQK7nDbUHTcwPn2 Tron (TRX):\nTYvFYUV3h5HwqfyTxskGQK7nDbUHTcwPn2 Monero (XMR):\n4AbxbT9vrNQTUDCQEPwVLYZq2zTEYzNr9ZzTLaq9YcwVfdxwkWjZ6FsewuXVDXPk7x2rE6FZACmLePPgJEcY4rm1GSHkwTZ ","date":"19 July 2022","permalink":"/posts/exorcism-with-python/","section":"Posts","summary":"Рассмотрим, как демонизировать наше python-приложение под Linux.","title":"Запуск Python приложения в качестве службы на Linux-сервер с systemd или причём тут экзорцизм"},{"content":" ","date":"1 January 0001","permalink":"/music/","section":"Owl's Paw","summary":" ","title":"Music"}]