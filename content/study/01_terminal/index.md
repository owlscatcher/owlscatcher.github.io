---
title: "Терминал: знакомство и базовые команды"
date: 2023-12-20T8:00:00+04:00
draft: false
tags: ["linux", "dev", "terminal", "bash"]
categories: ["tips", "study"]
---

Познакомимся с эмулятором терминала и базовыми действиями в нем.

# Терминал

В операционных системах на базе ядра [linux](https://kernel.org/), в случае с серверными версиями, существует только 1 
способ управления, который дошел до нас из 70-х годов — терминал, а точнее его эмулятор, так как сами терминалы, 
которые использовались для многопользовательского доступа к мейнфрейму давно остались в прошлом.

У терминала есть три способо взаимодействия с пользователем (также это называют **стандартным** I/O терминала или же 
[стандартными потоками](https://en.wikipedia.org/wiki/Standard_streams)):
- `STDIN` — поток чтения, из которого терминал читает программный и пользовательский ввод (сюда мы передаем наши команды);
- `STDOUT` — поток вывода, в который производится вывод результатов выполнения чего-либо, вывод сообщений, которые не 
попадают в категорию ошибок и тд;
- `STDERR` — поток вывода сообщений об ошибках.

Запоминать это не нужно, это дано для понимания, как операционная система взаимодействует с нами, а мы с ней.

Над терминалом будет работать одна из трех популярных shell-утилит, через которую мы и будем работать с терминалом:
- bash — самый старый представитель, присутствует в стандартных поставках;
- zsh — твикнутый bash, который во многом удобнее, но он не идет в стандартной поставке;
- fish — навороченный shell, который из-за этого становится достаточно тормозным.

Управление операционной системой происходит при помощи передачи аргументов в `STDIN` терминала. Базовые операции с 
операционной системой разберем ниже.

# Общаемся с операционной системой через терминал

Первое, что стоит знать о терминале, что мы может передавать вывод одной команды на вход другой (замечательны механизм 
трех стандартных стримов). Это происходит при помощи _пайпа_ `|`.

```bash
# результат поиска передается в фильтр
# фильтр отобразит файлы, включающие docx 

find ~/Documents doc  | grep -i docx
```

Можно строить большие цепочки вызовов утилит, передавая вывод одной на вход другой, иногда без этого нельзя обойтись.

Второе, что **нужно** знать, что выход из практически любой утилиты, которая перехватывает управление, происходит по 
кнопке `q`, а прерывание исполнения какой-либо утилиты происходит по комбинации кнопок `CTRL + c`.

## 0. Чтение документации

Чтобы прочитать справку или документацию по любой команде и её аргументам есть утилита `man`:

```bash
man <утилита_по_которой_нужна_справка>
```

Если забылся какой-то ключ аргумента или просто непонятно, как использовать ту или иную команду — You're welcome, как 
говорят в нашем посёлке.

## 1. Навигация и работа с файлами

Файловая система в \*NIX-подобных операционных системах не похода на привычную в Windows. У такой файловой системы 
есть корень, от которой она начинает ветвиться. Вот пример:

```bash
└── /
    ├── bin
    ├── boot
    ├── dev
    ├── etc
    ├── home
    └── ...
```

_Пример выведен при помощи утилиты [tree](https://linux.die.net/man/1/tree)_

Для навигации по директориям (здесь нет привычных "папок" из windows), копирования или перемещения файлов, просмотра 
текущей директории и тд используют следующие утилиты:

### CD

`cd` (change directory) — перейти в другую директорию. Это самая часто используемая утилита, вот как её можно использовать:

```bash
# перейти в папку по пути
cd /home/user/Documents

# тоже самое, только короче
cd ~/Documents

# вернуться на уровень выше
cd ../

# можно и так
cd ..

# вернуться на несколько уровней выше
cd ../../../

# вернуться сразу в домашнюю папку
cd 
```

### CP, MV и RM

`cp` (copy files) — копирует указанный файл или директорию в указанную директорию.

```bash
cp /home/<user>/Documents/study/file_1 /home/<user>/Documents
```

`mv` (move files) — перемещает или переименовывает файл/директорию.

```bash
# переместить файл
mv /home/<user>/Documents/study/file_1 /home/<user>/Documents

# переименовать файл
mv /home/<user>/Documents/study/file_1 /home/<user>/Documents/study/new_file_1
```

`rm` (remove files) — удаляет файл или директорию.

```bash
# удалить файл
rm /home/<user>/Documents/study/file_1

# удалить папку
rm -rf /home/<user>/Documents/study
```

### LS

`ls` (list directory contents) — отображает список файлов и директорий в текущей директории или по заданному пути.

```bash
# простое отображение из текущей директории
ls 

# вывод:
# ➜ dir_1  dir_2  file_1  file_2

# вывод списком из текущей директории
ls -l 

# вывод:
# total 0
# drwxr-xr-x 1 <user> <group> 0 Dec 20 08:59 dir_1
# drwxr-xr-x 1 <user> <group> 0 Dec 20 08:59 dir_2
# -rw-r--r-- 1 <user> <group> 0 Dec 20 08:59 file_1
# -rw-r--r-- 1 <user> <group> 0 Dec 20 08:59 file_2

# человекочитаемый вывод списком из текущей директории
# а также отображение скрытых файлов
ls -lah

# вывод:
# total 0
# drwxr-xr-x  1 <user> <group>   68 Dec 20 08:59 .
# drwxr-xr-x. 1 <user> <group> 1.2K Dec 20 08:59 ..
# drwxr-xr-x  1 <user> <group>    0 Dec 20 08:59 dir_1
# drwxr-xr-x  1 <user> <group>    0 Dec 20 08:59 dir_2
# -rw-r--r--  1 <user> <group>    0 Dec 20 08:59 file_1
# -rw-r--r--  1 <user> <group>    0 Dec 20 08:59 file_2
# -rw-r--r--  1 <user> <group>    0 Dec 20 08:59 .sicret_file

# тоже самое, только по заданному пути
ls -lah ~/Documents
```

### PWD

`pwd` (print name of current/working directory) — отображает текущую директорию 

```bash
pwd

# /home/<user>/Documents/study
```

## Работа с текстовыми файлами

Как правило в стандартной поставке есть множество утилит для работы с текстовыми файлами в том или ином виде. Далее 
мы разберем, как вывести текст файла, как открыть его для редактирования и тд.

### CAT, HEAD, TAIL

`cat`, `head` и `tail` выполняют по сути одну и туже функцию, но немного по-разному. Все три утилиты выводят текст в 
`STDOUT`:
- `cat` — выведет всё содержимое файла;
- `head` — выведет первые 10 строк содердимого файла;
- `tail` — выведет последние 10 строк содержимого файла.

Чтобы было проще запомнить эти команды, есть картинка с древних форумов:

![CAT, HEAD and TAIL](./cat.jpg)

У этих команд куча ключей, такие, как количество выводимых строй `head` и `tail` (ключ `-n`) и другие. Все это стоит 
прочитать в `man` этих утилит.

### LESS

`less` — это так называемый _пейджер_, который, как и `cat`-`head`-`tail`- выводит содержимое файла, но в интерактивном 
режиме и порциями (от того такие утилиты и называют _пейджерами_). 

В `less` реализовано _vim-подобное управление_, доступен поиск по тексту (команда `/`).

### Текстовые редакторы

В стандартной поставке 100% будет `Vi` или его обновленный собрат `VIM`, а также, скорее всего, `nano`.

Если не хочется заучивать сложные hot-keys в `VIM`, лучше использовать `nano`, он гораздо понятнее и проще, и хорошо 
подойдет вам, если просто нужно поправить какой-то конфигурационный файл.

В случае с `VIM` **главное** что нужно знать, это как из него выйти. Никакой магии, просто `:q`.

Для `VIM` в `man` есть огромная справка, а также в самом `VIM` есть отличный гайд по управлению этим крутым инстурментом.

Стоит отметить, что знать `VIM` все же стоит, потому что во многих инструментах используется _vim-подобное управление_.

## Процессы

### PS

`ps` (current processes) — отображает снимок запущенных процессов на момент вызова утилиты. Это бывает полезно, когда 
надо быстро глянуть, что сейчас работает на сервере. 

Эта утилита может помочь узнать `PID` процесса, например, чтобы его **прибить**.

### TOP и HTOP

Две утилиты, которые отображают запущенные процессы и информацию о них.

Эти утилиты также позволяют прибить процесс, выбрав из списка сигнал, который будет оправлен для завершения работы.

### KILL

`kill`, как понятно из названия, прибивает процесс по его `PID`. С этой утилитой нужно быть осторожным и не грохнуть 
какой-нибудь процесс, связанный с `ssh`, например, или с какой-нибудь системной утилитой.

## Поиск по файлам и фильтр вывода

### FIND

`find` — очень мощная утилита, которая производит рекурсивный поиск по всем саб-директориям.

Использовать её очень просто:

```bash
find ~/Documents -type f -iname report.pdf
```

Также можно искать файл по содержимому (тут используется фильтр `grep`, о нем ниже):

```bash
find . -type f -exec grep -l "pattern" {} \;
```

Или по его размеру:

```bash
find /path/to/search -type f -size +1M
```

### GREP

`grep` поход на `find`, только он выполняет фильтрацию вывода по заданному правилу. При помощи `grep` мы можем найти 
файл, в котором содержится какая-то строка текста (это работает для _plain text_ файлов), отфильтровать вывод другой 
утилиты и тд.

```bash
ls -lah | grep -i file_2

-rw-r--r--  1 <user> <group>    0 Dec 20 08:59 file_2
```

## Благодарности серому волшебнику

Если текст был полезен и ты не можешь усмирить желание быть благодарным, то можешь купить мне чашечку кофе: 

{{< buymeacoffee >}}

Воспользоваться моей реферальной ссылкой на DigitalOcean:

{{< digitalocean >}}

Или же закинуть монету в мой кошелёк (USDT и TRX кошельки одинаковые, да, это не ошибка):

**Tether (TRC-20, USDT):**

```markdown
TYvFYUV3h5HwqfyTxskGQK7nDbUHTcwPn2
```

**Tron (TRX):**

```markdown
TYvFYUV3h5HwqfyTxskGQK7nDbUHTcwPn2
```

**Monero (XMR):**

```markdown
4AbxbT9vrNQTUDCQEPwVLYZq2zTEYzNr9ZzTLaq9YcwVfdxwkWjZ6FsewuXVDXPk7x2rE6FZACmLePPgJEcY4rm1GSHkwTZ
```

