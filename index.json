[{"content":"","date":"6 November 2022","permalink":"/","section":"","summary":"","title":""},{"content":"","date":"6 November 2022","permalink":"/tags/armstrong/","section":"Tags","summary":"","title":"armstrong"},{"content":"","date":"6 November 2022","permalink":"/categories/armstrong/","section":"Categories","summary":"","title":"armstrong"},{"content":" ARMStrong: как мы собираем отчеты по выбросам # Контроль, контроль и еще раз контроль! Смотрим, какое количество активных газов мы выбрасываем, оцениваем их вес и формируем отчеты. Внимание! Спасибо за внимание. Введение # На атомных, хим и металлургических предприятиях всегда требуется контроль за уровнем выхода активных веществ, которое сбрасывает предприятие. Эти уровни устанавливаются нормативными актами и не должны быть превышены.\nНа различных предприятиях отчетность ведётся по-разному, мы же разберем случай, когда есть оперативный контроллирующий персонал, который должен заносить запись об контроллируемой обстановке в оперативный журнал каждые n часов, в начале смены или же посуточно.\nДля этих целей был разработан небольшой модуль для клиента ARMStrong, который и будет формировать отчетность по выбрасываемым газам, средней активности на МЭД-точках контроля и \\(I_{131}\\)-участке.\nРассчитываем выбросы # Для справки: каждая точка представляет собой объект из истории измерений, который имеет три свойства:\npublic class History { public int Id { get; } public double SystemEventValue { get; } public DateTime EventDateTime { get; } } Что бы вычислить, сколько Бк было выброшено, нам нужно знать значение на момент начала расчёта, продолжительность выброса и значение на момент окончания расчёта. Значение на момент начала и окончания расчёта мы принимаем за \\(N_1\\) и \\(N_2\\) соответственно.\nЗа продолжительность выброса мы возьмем \\(\\Delta T\\), которая является просто разницей по времени между второй и первой точкой.\nТаким образом для вычисления выброса нам требуется две точки и выброс будет расчитываться как:\n\\(S = \\dfrac{N_1 + N_2}{2} \\Delta T\\)\nСреднее по этим точкам мы берем по причине, что не представляется возможным предугадать, в какой момент времени между двумя соседними точками начался рост или спад. Минимальное время регистрации можно устанавливать в 2.5 секунды, но ввиду особенности блоков детектирования типа БДГБ-02П и подобных сокращать окно практически бессмысленно, это не приводит к увеличению точность.\nДалее, чтобы вычислить суммарный расход, нужно просто просуммировать все результаты и умножить на расход по вентсистеме точки контроля.\nРасход хранится в формате \\(\\dfrac{м^3}{час}\\), поэтому требуется привести его к \\(\\dfrac{м^3}{сек}\\), для этого просто разделим его на 3600.\nУчитывая вышесказанное мы можем вывести формулу расчета выбросов и применить её в коде клиента:\n\\(S_{sum} = (\\sum{\\dfrac{N_1 + N_2}{2} \\Delta T}) C*{sec} \\), где:\n\\(S_{sum}\\) \u0026ndash; суммарный выброс по точке контроля, \\(Бк\\); \\(\\dfrac{N_1 + N_2}{2}\\) \u0026ndash; среднее значение по двум точкам, \\(\\dfrac{Бк}{м^3}\\) \\(\\Delta T\\) \u0026ndash; длительность выброса \\(T_2 - T_1\\), \\(сек.\\); \\(C_{sec}\\) \u0026ndash; расход газа через вентсистему точки контроля \\(\\dfrac{C_{hour}}{3600}\\), \\(\\dfrac{м^3}{сек}\\). Метод для расчета выбросов будет следующим:\npublic double GetSystemBlowout(List\u0026lt;History\u0026gt; histories, Channel channel) { double summaryBlowout, rawBlowoutSumm = 0; for (int i = 0; i \u0026lt; histories.Count - 1; i++) { DateTime firstPointDateTime = histories[i].EventDate; DateTime secondPointDateTime = histories[i + 1].EventDate; double deltaT = secondPointDateTime .Substract(firstPointDateTime) .TotalSeconds; double firstPointValue = histories[i].SystemEventValue; double secondPointValue = histories[i + 1].SystemEventValue; dobule averageValue = (firstPointValue + secondPointValue) / 2; rawBlowoutSumm += averageValue * deltaT; } double consumprion = channel.ChannelConsumption / 3600; summaryBlowout = rawBlowoutSumm * consumption; return summaryBlowout; } Группируем выбросы по категориям # // TODO завтра Рассчитываем среднее по МЭД и йодному участку # // TODO Отображаем пользователю отчёт # Мы рассчитали выбросы, посчитали МЭД и йод, теперь настало время показать пользователю то, что мы насчитали.\nОтображать отчёты будем в виде таблиц с эспандером, которым будут закрыты все лишние таблицы, что бы не отвлекали.\nПользователю будет предложен выбор интервала, за который он хочет получить отчет:\nДалее будет собран и отображен сам отчёт:\nВ планах # Добавить файл настроек, в котором можно будет перечислять группы и параметры, по которым будет происходить сборка отчетов; Добавить возможность вывода отчёта в файл и/или отправка отчёта по почте. ","date":"6 November 2022","permalink":"/posts/arms-blowout-report/","section":"Posts","summary":"ARMStrong: как мы собираем отчеты по выбросам # Контроль, контроль и еще раз контроль!","title":"ARMStrong: отчет по выбросам"},{"content":"","date":"6 November 2022","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"6 November 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"6 November 2022","permalink":"/categories/projects/","section":"Categories","summary":"","title":"projects"},{"content":"","date":"6 November 2022","permalink":"/tags/report/","section":"Tags","summary":"","title":"report"},{"content":"","date":"6 November 2022","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"19 July 2022","permalink":"/categories/blog/","section":"Categories","summary":"","title":"blog"},{"content":"","date":"19 July 2022","permalink":"/tags/dev/","section":"Tags","summary":"","title":"dev"},{"content":"","date":"19 July 2022","permalink":"/tags/linux/","section":"Tags","summary":"","title":"linux"},{"content":"","date":"19 July 2022","permalink":"/tags/python/","section":"Tags","summary":"","title":"python"},{"content":"Дьявол в деталях # В начале сотворил он небо и землю На второй день разделил он свет и тьму\n\u0026hellip;\nНа седьмой день разобрался он с systemd, запустил в фоне службы, автоматизирующие процессы, и больше никогда не был online.\nПривет-привет, оклахома кидс! В этой заметке мы будем разбираться, что нужно делать дальше, когда мы написали приложение и у нас есть сервер.\nК сожалению, недостаточно просто выгрузить приложение на удаленный сервер и запустить скрипт, например так:\nPython3 ~/MyFirstDeploy/best_fucking_idea.py Приложение запустится и даже будет работать. Но есть одно но: после того, как вы вышли с сервера, закрыв ssh-соединение, вы закрыли все запущенные вами приложения в этой сессии, в том числе и запущенный скрипт, потому что вы закрыли не только ssh-соединение, а вообще закрыли сессию, которая была создана для этого пользователя.\nЧто бы такого не происходило приложение требуется демонизировать и вынести его выполнение за рамки конкретного пользователя. Это можно сделать как средствами операционной системы (этот метод описан в этой заметке), так и запрограммировать руками (но это пипец какой костыль, не находите?)\nВ операционных системах на базе Linux организация пользователей координально отличается от Windows. Это является сильной стороной Linux-base систем и одновременно с этим, по первости, добавляет нам проблем в копилку непонимания и ахуевания, но освоившись вы почувствуете все приемущества такого подхода к разграничению пользователей.\nКстати, благодаря такому подходу к организации пользователей в Linux-base системах и появился Docker, который стал стандартом дефакто в современном мире web-разработки, привнеся в неё контейнеризацию, которая позволяет в 1 клик поднять огромный сервис на тысячах машинах, а вторым кликом почти мгновенно масштабировать мощности сервиса. В операционных Linux-base системах все привычные в windows службы (service) называют демонами (daemon). Здесь и дальше под словом демон я буду подразумевать службу, которая выполняется в фоновом режиме.\nДемон (daemon) — это всего лишь компьютерная программа, которая под управлением систем инициализации блоков способна запускать процессы в фоновом режиме. И для того, чтобы наше приложение могло запускаться в виде демона / быть демоном, его нужно демонизировать. Этим мы и займёмся дальше, но сначала мы обратим внимание на заголовок статьи. Причём тут какой-то systemd?\nSystemd — это системный диспетчер. Аналогию можно провести с диспетчером задач, который является частью менеджера процессов в windows. Этот парень позволяет нам управлять почти всеми демонами в нашей операционной системе, помогает создавать конфигурации этих демонов и прч. Не все операционные системы на базе Linux используют systemd, так что это нужно учитывать. Systemd в свою очередь работает с помощью systemctl.\nSystemctl — это инструмент центрального управления для контроля системы инициализациии. С помощью этого парня мы будем запускать, останавливать и проверять статус нашего процесса.\nВводную получили, поехали стучать по клавишам!\nМой лучший друг — демон # Итак, у нас было:\nПриложение на Python Сервер на linux с systemd Огромное желание что-то запускать Я буду использовать свой droplet на digital ocean, вы можете использовать хоть виртуальную машину на своём компьютере, разницы 0.\nИтак, мы зашли по ssh на наш сервер, предварительно загрузили на этот сервер файлы приложения, например по этому пути:\n/root/telegram-bot И нам нужно, чтобы запускался скрипт [bot.py](http://bot.py). Это точка входа в наше приложение.\nПолучаем такой путь до нашей точки входа: /root/telegram-bot/bot.py. Этот путь я буду дальше использовать для примеров.\nДля того, что бы создать демона нашего скрипта, требуется сделать ряд вещей:\nСоздать файл \u0026lt;name\u0026gt;.service, в котором будет описана конфигурация нашего демона Попросить systemctl перечитать все файлы настроек демонов Рассказать systemctl о нашем демоне (создаст semilink) Запустить демона! План понятен и приятен. Но где вообще живут эти демоны и чёэтатакое?!\nЗаходим на наш сервер:\nssh \u0026lt;user\u0026gt;@\u0026lt;server_ip_address\u0026gt; Идем смотреть на демонов:\ncd /etc/systemd/system/ \u0026amp;\u0026amp; ls -lah ./ И видим примерно следующую картину:\ndrwxr-xr-x 21 root root 4.0K May 6 08:43 . drwxr-xr-x 6 root root 4.0K May 6 05:50 .. ... drwxr-xr-x 2 root root 4.0K May 6 05:50 sshd-keygen@.service.d lrwxrwxrwx 1 root root 31 Jan 31 22:28 sshd.service -\u0026gt; /lib/systemd/system/ssh.service drwxr-xr-x 2 root root 4.0K Jan 31 22:28 sysinit.target.wants lrwxrwxrwx 1 root root 35 Jan 31 22:26 syslog.service -\u0026gt; /lib/systemd/system/rsyslog.service drwxr-xr-x 2 root root 4.0K Jan 31 22:28 timers.target.wants lrwxrwxrwx 1 root root 41 Jan 31 22:28 vmtoolsd.service -\u0026gt; /lib/systemd/system/open-vm-tools.service Файлы \u0026lt;name\u0026gt;.service — описание демона. Там лежит вся его настройка\nПапки \u0026lt;name\u0026gt;.service.d — это папка, в которой лежит дополнительная настройка демона. По умолчанию она не создается, но мы в нашем примере будем её создавать и положим туда часть настройки демона.\nСоздадим новый файл конфигурации демона для нашего приложения.\nСоздаём конфигурацию демона # Без лишних слов, будучи в папке /etc/systemd/system/\nvim bot.service Откроется редактор [VIM](https://www.vim.org/), в котором мы будем описывать нашего демона:\n[Unit] Description=My telegram bot After=multi-user.target [Service] Type=simple Restart=always ExecStart=/usr/bin/python3 /root/telegram-bot/bot.py [Install] WantedBy=multi-user.target Вот в целом - то и всё. После обновления systemctl можно запустить сервис. Но мы разберемся немного подробнее, за что отвечает каждый ключ в каждой секции.\nСекция Unit:\nDescription — Просто описание вашего сервиса, которое будет выведено при выполнении systemctl status \u0026lt;name\u0026gt; в статус-строке, после названия демона. Может быть вообще произвольным. After — Определяет порядок запуска блоков. Здесь multi-user.target указывает на цель, в которой описаны другие службы. Т.е. наш демон запустится только после того, как все службы, указанные в multi-user.target были успешно запущены. Например, в multi-user.target важные системные службы, такие как NetworkManager (NetworkManager.service) или D-Bus (dbus.service) и инструкция запуска другого целевого блока с именем basic.target. Секция Service:\nType — Настраивает тип демона, этот ключ на прямую влияет на то, как будет выполняется инструкция в ExecStart. simple — Значение по умолчанию. Процесс начинается с инструкции ExecStart и является основным процессом forking — Процесс начинается с ExecStart и порождает дочерний процесс, который замещает собой родительский процесс. oneshot — аналогичен simple, только процесс завершается до запуска последующих блоков. \u0026hellip; и т.д. Ссылку на описание всех ключей оставлю ниже. Нас же интересует только simple. Restart — Указывает на то, будет ли перезапущена служба после завершения процесса. Указываем always, что бы не быть неприятно удивленными каким-нибудь вечером. ExecStart — Инструкция, которая исполнится при запуске демона. В данном примере я указал абсолютные пути до Python и до моего скрипта, который является точкой входа в приложение. Можно упростить до python3 /root/telegram-bot/bot.py, но лучше перестраховаться на случай, если на сервере не прокинуты $PATH. Секция Install:\nWantedBy — указывает на зависимости, причем делает это мягче, чем ключ RequareBy, который бы прервал выполнение, в случае неудачного запуска одной из служб. Описание всех ключей тут.\nПрячем от чужих глаз чувствительные данные # Бывает такое, что приложение использует какие-то пароли / ключи / токены и тд, которые не стоит держать в открытом виде в скрипте или где-то рядом с ним, что бы случайно не выгрузить на github в публичный репозиторий. В таком случае можно восппользоваться переменными окружения или Environment variable.\nТак как наше приложение будет запущено в качестве демона, то нельзя просто так прокинуть эти переменные, допустим, пользователю root. Мы будем использовать дополнительную настройку нашего демона, в которой переопределим этот блок (вспоминаем про папки \u0026lt;name\u0026gt;.service.d)\nДля этого воспользуемся аргументом edit у systemctl и создадим для нашей настройки bot.service доп настройку с нашими переменными окружения:\nsystemctl edit bot.service Откроется редактор nano с пустым файлом. Внесем туда свои переменный, переопределив блок [Service]:\n[Service] Environment=\u0026#34;telegram=\u0026lt;your_token\u0026gt;\u0026#34; Environment=\u0026#34;openweathermap=\u0026lt;your_token\u0026gt;\u0026#34; Environment=\u0026#34;resources_path=/root/telegram-bot/resources\u0026#34; Далее нажимаем Ctrl + O, чтобы записать наш файл на диск, назовем его local.conf, и нажимаем Ctrl + X для выхода.\nМожем проверить, что у нас получилось:\n. ├── bot.service ├── bot.service.d │ └── local.conf Видим наш файл настройки bot.service и дополнительная конфигурация local.conf в папке bot.service.d.\nТеперь при запуске службы будут подтянуты переменные окружения и ваш код приложения, который требовал эти самые environment variable будет отрабатывать как положено.\nЗапускаем и проверяем статус нашего демона # Мы сделали все нужные настройки, теперь надо рассказать нашему systemctl о нашем демоне, добавить его в автозапуск и запустить наконец-то.\nОбновляем информацию о демонах:\nsystemctl daemon-reload Добавляем в автозагрузку:\nsystemctl enable bot.service Запускаем:\nsystemctl start bot.service Проверим статус, запустился ли вообще сервис или упал:\nsystemctl status bot.service Должны увидеть вот такое сообщение:\n● bot.service - My telegram bot Loaded: loaded (/etc/systemd/system/bot.service; enabled; vendor preset: enabled) Drop-In: /etc/systemd/system/bot.service.d └─local.conf Active: active (running) since Fri 2022-05-06 09:17:11 UTC; 24h ago ... Если в статусе Failed, значит либо что-то с приложением, либо что-то с настройкой. Можно пойти почитать логи коммандой [dmesg](https://manpages.org/dmesg) или cat /var/log/syslog.\nПолезные ссылки # Простейший способ превратить скрипт в демона, Linkolnloop, Graham King Руководство для начинающих по systemctl, BitLaunch Использование Systemctl для управления системой и юнитами, библиотека Digital Ocean Управление службами с помощью systemd, документация Red Hat Описание всех ключей файла конфигурации службы, документация Red Hat Как создать и удалить символическую ссылку, freecodecamp, Dillion Megida Как читать и устанавливать переменные среды и shell в Linux, библиотека Digital Ocean Благодарности серому волшебнику # Если текст был полезен и ты не можешь усмирить желание быть благодарным, то вот мои кошелечки (USDT и TRX кошельки одинаковые, да, это не ошибка):\nTether (TRC-20, USDT):\nTYvFYUV3h5HwqfyTxskGQK7nDbUHTcwPn2 Tron (TRX):\nTYvFYUV3h5HwqfyTxskGQK7nDbUHTcwPn2 Monero (XMR):\n4AbxbT9vrNQTUDCQEPwVLYZq2zTEYzNr9ZzTLaq9YcwVfdxwkWjZ6FsewuXVDXPk7x2rE6FZACmLePPgJEcY4rm1GSHkwTZ ","date":"19 July 2022","permalink":"/posts/exorcism-with-python/","section":"Posts","summary":"Дьявол в деталях # В начале сотворил он небо и землю На второй день разделил он свет и тьму","title":"Запуск Python приложения в качестве службы на Linux-сервер с systemd или причём тут экзорцизм"},{"content":"","date":"1 January 0001","permalink":"/about/","section":"","summary":"","title":""}]